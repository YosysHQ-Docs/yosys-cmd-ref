{
  "version": "Yosys internal cells",
  "generator": "Yosys 0.42+40 (git sha1 b82854123, ccache clang++ 10.0.0-4ubuntu1 -fPIC -Os)",
  "groups": {
    "arith": ["$alu", "$lcu", "$macc"],
    "binary": ["$logic_or", "$logic_and", "$pow", "$modfloor", "$divfloor", "$mod", "$div", "$mul", "$sub", "$add", "$gt", "$ge", "$nex", "$eqx", "$ne", "$eq", "$le", "$lt", "$shiftx", "$shift", "$sshr", "$sshl", "$shr", "$shl", "$xnor", "$xor", "$or", "$and"],
    "debug": ["$check", "$print"],
    "formal": ["$anyinit", "$ff", "$equiv", "$allseq", "$allconst", "$anyseq", "$anyconst", "$initstate", "$cover", "$fair", "$live", "$assume", "$assert"],
    "fsm": ["$fsm"],
    "gate_other": ["$_DLATCHSR_PPP_", "$_DLATCHSR_PPN_", "$_DLATCHSR_PNP_", "$_DLATCHSR_PNN_", "$_DLATCHSR_NPP_", "$_DLATCHSR_NPN_", "$_DLATCHSR_NNP_", "$_DLATCHSR_NNN_", "$_DLATCH_PP1_", "$_DLATCH_PP0_", "$_DLATCH_PN1_", "$_DLATCH_PN0_", "$_DLATCH_NP1_", "$_DLATCH_NP0_", "$_DLATCH_NN1_", "$_DLATCH_NN0_", "$_DLATCH_P_", "$_DLATCH_N_", "$_SDFFCE_PP1P_", "$_SDFFCE_PP1N_", "$_SDFFCE_PP0P_", "$_SDFFCE_PP0N_", "$_SDFFCE_PN1P_", "$_SDFFCE_PN1N_", "$_SDFFCE_PN0P_", "$_SDFFCE_PN0N_", "$_SDFFCE_NP1P_", "$_SDFFCE_NP1N_", "$_SDFFCE_NP0P_", "$_SDFFCE_NP0N_", "$_SDFFCE_NN1P_", "$_SDFFCE_NN1N_", "$_SDFFCE_NN0P_", "$_SDFFCE_NN0N_", "$_SDFFE_PP1P_", "$_SDFFE_PP1N_", "$_SDFFE_PP0P_", "$_SDFFE_PP0N_", "$_SDFFE_PN1P_", "$_SDFFE_PN1N_", "$_SDFFE_PN0P_", "$_SDFFE_PN0N_", "$_SDFFE_NP1P_", "$_SDFFE_NP1N_", "$_SDFFE_NP0P_", "$_SDFFE_NP0N_", "$_SDFFE_NN1P_", "$_SDFFE_NN1N_", "$_SDFFE_NN0P_", "$_SDFFE_NN0N_", "$_SDFF_PP1_", "$_SDFF_PP0_", "$_SDFF_PN1_", "$_SDFF_PN0_", "$_SDFF_NP1_", "$_SDFF_NP0_", "$_SDFF_NN1_", "$_SDFF_NN0_", "$_DFFSRE_PPPP_", "$_DFFSRE_PPPN_", "$_DFFSRE_PPNP_", "$_DFFSRE_PPNN_", "$_DFFSRE_PNPP_", "$_DFFSRE_PNPN_", "$_DFFSRE_PNNP_", "$_DFFSRE_PNNN_", "$_DFFSRE_NPPP_", "$_DFFSRE_NPPN_", "$_DFFSRE_NPNP_", "$_DFFSRE_NPNN_", "$_DFFSRE_NNPP_", "$_DFFSRE_NNPN_", "$_DFFSRE_NNNP_", "$_DFFSRE_NNNN_", "$_DFFSR_PPP_", "$_DFFSR_PPN_", "$_DFFSR_PNP_", "$_DFFSR_PNN_", "$_DFFSR_NPP_", "$_DFFSR_NPN_", "$_DFFSR_NNP_", "$_DFFSR_NNN_", "$_ALDFFE_PPP_", "$_ALDFFE_PPN_", "$_ALDFFE_PNP_", "$_ALDFFE_PNN_", "$_ALDFFE_NPP_", "$_ALDFFE_NPN_", "$_ALDFFE_NNP_", "$_ALDFFE_NNN_", "$_ALDFF_PP_", "$_ALDFF_PN_", "$_ALDFF_NP_", "$_ALDFF_NN_", "$_DFFE_PP1P_", "$_DFFE_PP1N_", "$_DFFE_PP0P_", "$_DFFE_PP0N_", "$_DFFE_PN1P_", "$_DFFE_PN1N_", "$_DFFE_PN0P_", "$_DFFE_PN0N_", "$_DFFE_NP1P_", "$_DFFE_NP1N_", "$_DFFE_NP0P_", "$_DFFE_NP0N_", "$_DFFE_NN1P_", "$_DFFE_NN1N_", "$_DFFE_NN0P_", "$_DFFE_NN0N_", "$_DFF_PP1_", "$_DFF_PP0_", "$_DFF_PN1_", "$_DFF_PN0_", "$_DFF_NP1_", "$_DFF_NP0_", "$_DFF_NN1_", "$_DFF_NN0_", "$_DFFE_PP_", "$_DFFE_PN_", "$_DFFE_NP_", "$_DFFE_NN_", "$_DFF_P_", "$_DFF_N_", "$_FF_", "$_SR_PP_", "$_SR_PN_", "$_SR_NP_", "$_SR_NN_", "$_TBUF_", "$_OAI4_", "$_AOI4_", "$_OAI3_", "$_AOI3_", "$_MUX16_", "$_MUX8_", "$_MUX4_", "$_NMUX_", "$_MUX_", "$_ORNOT_", "$_ANDNOT_", "$_XNOR_", "$_XOR_", "$_NOR_", "$_OR_", "$_NAND_", "$_AND_", "$_NOT_", "$_BUF_"],
    "logic": ["$sop", "$lut"],
    "mem": ["$mem_v2", "$mem", "$meminit_v2", "$meminit", "$memwr_v2", "$memwr", "$memrd_v2", "$memrd"],
    "mux": ["$tribuf", "$demux", "$bmux", "$pmux", "$mux"],
    "reg": ["$dlatchsr", "$adlatch", "$dlatch", "$sdffce", "$sdffe", "$sdff", "$aldffe", "$aldff", "$adffe", "$adff", "$dffsre", "$dffsr", "$dffe", "$dff", "$sr"],
    "spec": ["$specrule", "$specify3", "$specify2"],
    "unary": ["$logic_not", "$reduce_bool", "$reduce_xnor", "$reduce_xor", "$reduce_or", "$reduce_and", "$neg", "$pos", "$not"],
    "word_other": ["$scopeinfo", "$future_ff", "$original_tag", "$overwrite_tag", "$get_tag", "$set_tag", "$fa", "$bwmux", "$bweqx", "$concat", "$slice"]
  },
  "cells": {
    "$_ALDFFE_NNN_": {
      "title": "",
      "ports": "(D, C, L, AD, E, Q)",
      "source": "simcells.v:1360",
      "desc": "A negative edge D-type flip-flop with negative polarity async load and negative\npolarity clock enable.\n::\n\n   Truth table:    D C L AD E | Q\n                  ------------+---\n                   - - 0 a  - | a\n                   d \\ - -  0 | d\n                   - - - -  - | q",
      "code": "module \\$_ALDFFE_NNN_ (D, C, L, AD, E, Q);\n    input D, C, L, AD, E;\n    output reg Q;\n    always @(negedge C or negedge L) begin\n        if (L == 0)\n            Q <= AD;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\AD", "\\L", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_ALDFFE_NNP_": {
      "title": "",
      "ports": "(D, C, L, AD, E, Q)",
      "source": "simcells.v:1384",
      "desc": "A negative edge D-type flip-flop with negative polarity async load and positive\npolarity clock enable.\n::\n\n   Truth table:    D C L AD E | Q\n                  ------------+---\n                   - - 0 a  - | a\n                   d \\ - -  1 | d\n                   - - - -  - | q",
      "code": "module \\$_ALDFFE_NNP_ (D, C, L, AD, E, Q);\n    input D, C, L, AD, E;\n    output reg Q;\n    always @(negedge C or negedge L) begin\n        if (L == 0)\n            Q <= AD;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\AD", "\\L", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_ALDFFE_NPN_": {
      "title": "",
      "ports": "(D, C, L, AD, E, Q)",
      "source": "simcells.v:1408",
      "desc": "A negative edge D-type flip-flop with positive polarity async load and negative\npolarity clock enable.\n::\n\n   Truth table:    D C L AD E | Q\n                  ------------+---\n                   - - 1 a  - | a\n                   d \\ - -  0 | d\n                   - - - -  - | q",
      "code": "module \\$_ALDFFE_NPN_ (D, C, L, AD, E, Q);\n    input D, C, L, AD, E;\n    output reg Q;\n    always @(negedge C or posedge L) begin\n        if (L == 1)\n            Q <= AD;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\AD", "\\L", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_ALDFFE_NPP_": {
      "title": "",
      "ports": "(D, C, L, AD, E, Q)",
      "source": "simcells.v:1432",
      "desc": "A negative edge D-type flip-flop with positive polarity async load and positive\npolarity clock enable.\n::\n\n   Truth table:    D C L AD E | Q\n                  ------------+---\n                   - - 1 a  - | a\n                   d \\ - -  1 | d\n                   - - - -  - | q",
      "code": "module \\$_ALDFFE_NPP_ (D, C, L, AD, E, Q);\n    input D, C, L, AD, E;\n    output reg Q;\n    always @(negedge C or posedge L) begin\n        if (L == 1)\n            Q <= AD;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\AD", "\\L", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_ALDFFE_PNN_": {
      "title": "",
      "ports": "(D, C, L, AD, E, Q)",
      "source": "simcells.v:1456",
      "desc": "A positive edge D-type flip-flop with negative polarity async load and negative\npolarity clock enable.\n::\n\n   Truth table:    D C L AD E | Q\n                  ------------+---\n                   - - 0 a  - | a\n                   d / - -  0 | d\n                   - - - -  - | q",
      "code": "module \\$_ALDFFE_PNN_ (D, C, L, AD, E, Q);\n    input D, C, L, AD, E;\n    output reg Q;\n    always @(posedge C or negedge L) begin\n        if (L == 0)\n            Q <= AD;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\AD", "\\L", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_ALDFFE_PNP_": {
      "title": "",
      "ports": "(D, C, L, AD, E, Q)",
      "source": "simcells.v:1480",
      "desc": "A positive edge D-type flip-flop with negative polarity async load and positive\npolarity clock enable.\n::\n\n   Truth table:    D C L AD E | Q\n                  ------------+---\n                   - - 0 a  - | a\n                   d / - -  1 | d\n                   - - - -  - | q",
      "code": "module \\$_ALDFFE_PNP_ (D, C, L, AD, E, Q);\n    input D, C, L, AD, E;\n    output reg Q;\n    always @(posedge C or negedge L) begin\n        if (L == 0)\n            Q <= AD;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\AD", "\\L", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_ALDFFE_PPN_": {
      "title": "",
      "ports": "(D, C, L, AD, E, Q)",
      "source": "simcells.v:1504",
      "desc": "A positive edge D-type flip-flop with positive polarity async load and negative\npolarity clock enable.\n::\n\n   Truth table:    D C L AD E | Q\n                  ------------+---\n                   - - 1 a  - | a\n                   d / - -  0 | d\n                   - - - -  - | q",
      "code": "module \\$_ALDFFE_PPN_ (D, C, L, AD, E, Q);\n    input D, C, L, AD, E;\n    output reg Q;\n    always @(posedge C or posedge L) begin\n        if (L == 1)\n            Q <= AD;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\AD", "\\L", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_ALDFFE_PPP_": {
      "title": "",
      "ports": "(D, C, L, AD, E, Q)",
      "source": "simcells.v:1528",
      "desc": "A positive edge D-type flip-flop with positive polarity async load and positive\npolarity clock enable.\n::\n\n   Truth table:    D C L AD E | Q\n                  ------------+---\n                   - - 1 a  - | a\n                   d / - -  1 | d\n                   - - - -  - | q",
      "code": "module \\$_ALDFFE_PPP_ (D, C, L, AD, E, Q);\n    input D, C, L, AD, E;\n    output reg Q;\n    always @(posedge C or posedge L) begin\n        if (L == 1)\n            Q <= AD;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\AD", "\\L", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_ALDFF_NN_": {
      "title": "",
      "ports": "(D, C, L, AD, Q)",
      "source": "simcells.v:1267",
      "desc": "A negative edge D-type flip-flop with negative polarity async load.\n::\n\n   Truth table:    D C L AD | Q\n                  ----------+---\n                   - - 0 a  | a\n                   d \\ - -  | d\n                   - - - -  | q",
      "code": "module \\$_ALDFF_NN_ (D, C, L, AD, Q);\n    input D, C, L, AD;\n    output reg Q;\n    always @(negedge C or negedge L) begin\n        if (L == 0)\n            Q <= AD;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\AD", "\\L", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_ALDFF_NP_": {
      "title": "",
      "ports": "(D, C, L, AD, Q)",
      "source": "simcells.v:1290",
      "desc": "A negative edge D-type flip-flop with positive polarity async load.\n::\n\n   Truth table:    D C L AD | Q\n                  ----------+---\n                   - - 1 a  | a\n                   d \\ - -  | d\n                   - - - -  | q",
      "code": "module \\$_ALDFF_NP_ (D, C, L, AD, Q);\n    input D, C, L, AD;\n    output reg Q;\n    always @(negedge C or posedge L) begin\n        if (L == 1)\n            Q <= AD;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\AD", "\\L", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_ALDFF_PN_": {
      "title": "",
      "ports": "(D, C, L, AD, Q)",
      "source": "simcells.v:1313",
      "desc": "A positive edge D-type flip-flop with negative polarity async load.\n::\n\n   Truth table:    D C L AD | Q\n                  ----------+---\n                   - - 0 a  | a\n                   d / - -  | d\n                   - - - -  | q",
      "code": "module \\$_ALDFF_PN_ (D, C, L, AD, Q);\n    input D, C, L, AD;\n    output reg Q;\n    always @(posedge C or negedge L) begin\n        if (L == 0)\n            Q <= AD;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\AD", "\\L", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_ALDFF_PP_": {
      "title": "",
      "ports": "(D, C, L, AD, Q)",
      "source": "simcells.v:1336",
      "desc": "A positive edge D-type flip-flop with positive polarity async load.\n::\n\n   Truth table:    D C L AD | Q\n                  ----------+---\n                   - - 1 a  | a\n                   d / - -  | d\n                   - - - -  | q",
      "code": "module \\$_ALDFF_PP_ (D, C, L, AD, Q);\n    input D, C, L, AD;\n    output reg Q;\n    always @(posedge C or posedge L) begin\n        if (L == 1)\n            Q <= AD;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\AD", "\\L", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_ANDNOT_": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simcells.v:189",
      "desc": "A 2-input AND-NOT gate.\n::\n\n   Truth table:    A B | Y\n                  -----+---\n                   0 0 | 0\n                   0 1 | 0\n                   1 0 | 1\n                   1 1 | 0",
      "code": "module \\$_ANDNOT_ (A, B, Y);\n    input A, B;\n    output Y;\n    assign Y = A & (~B);\nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$_AND_": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simcells.v:75",
      "desc": "A 2-input AND gate.\n::\n\n   Truth table:    A B | Y\n                  -----+---\n                   0 0 | 0\n                   0 1 | 0\n                   1 0 | 0\n                   1 1 | 1",
      "code": "module \\$_AND_ (A, B, Y);\n    input A, B;\n    output Y;\n    assign Y = A & B;\nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$_AOI3_": {
      "title": "",
      "ports": "(A, B, C, Y)",
      "source": "simcells.v:351",
      "desc": "A 3-input And-Or-Invert gate.\n::\n\n   Truth table:    A B C | Y\n                  -------+---\n                   0 0 0 | 1\n                   0 0 1 | 0\n                   0 1 0 | 1\n                   0 1 1 | 0\n                   1 0 0 | 1\n                   1 0 1 | 0\n                   1 1 0 | 0\n                   1 1 1 | 0",
      "code": "module \\$_AOI3_ (A, B, C, Y);\n    input A, B, C;\n    output Y;\n    assign Y = ~((A & B) | C);\nendmodule",
      "inputs": ["\\C", "\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$_AOI4_": {
      "title": "",
      "ports": "(A, B, C, D, Y)",
      "source": "simcells.v:405",
      "desc": "A 4-input And-Or-Invert gate.\n::\n\n   Truth table:    A B C D | Y\n                  ---------+---\n                   0 0 0 0 | 1\n                   0 0 0 1 | 1\n                   0 0 1 0 | 1\n                   0 0 1 1 | 0\n                   0 1 0 0 | 1\n                   0 1 0 1 | 1\n                   0 1 1 0 | 1\n                   0 1 1 1 | 0\n                   1 0 0 0 | 1\n                   1 0 0 1 | 1\n                   1 0 1 0 | 1\n                   1 0 1 1 | 0\n                   1 1 0 0 | 0\n                   1 1 0 1 | 0\n                   1 1 1 0 | 0\n                   1 1 1 1 | 0",
      "code": "module \\$_AOI4_ (A, B, C, D, Y);\n    input A, B, C, D;\n    output Y;\n    assign Y = ~((A & B) | (C & D));\nendmodule",
      "inputs": ["\\D", "\\C", "\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$_BUF_": {
      "title": "",
      "ports": "(A, Y)",
      "source": "simcells.v:39",
      "desc": "A buffer. This cell type is always optimized away by the opt_clean pass.\n::\n\n   Truth table:    A | Y\n                  ---+---\n                   0 | 0\n                   1 | 1",
      "code": "module \\$_BUF_ (A, Y);\n    input A;\n    output Y;\n    assign Y = A;\nendmodule",
      "inputs": ["\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$_DFFE_NN0N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:884",
      "desc": "A negative edge D-type flip-flop with negative polarity reset and negative\npolarity clock enable.\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - - 0 - | 0\n                   d \\ - 0 | d\n                   - - - - | q",
      "code": "module \\$_DFFE_NN0N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C or negedge R) begin\n        if (R == 0)\n            Q <= 0;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFE_NN0P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:908",
      "desc": "A negative edge D-type flip-flop with negative polarity reset and positive\npolarity clock enable.\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - - 0 - | 0\n                   d \\ - 1 | d\n                   - - - - | q",
      "code": "module \\$_DFFE_NN0P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C or negedge R) begin\n        if (R == 0)\n            Q <= 0;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFE_NN1N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:932",
      "desc": "A negative edge D-type flip-flop with negative polarity set and negative\npolarity clock enable.\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - - 0 - | 1\n                   d \\ - 0 | d\n                   - - - - | q",
      "code": "module \\$_DFFE_NN1N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C or negedge R) begin\n        if (R == 0)\n            Q <= 1;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFE_NN1P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:956",
      "desc": "A negative edge D-type flip-flop with negative polarity set and positive\npolarity clock enable.\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - - 0 - | 1\n                   d \\ - 1 | d\n                   - - - - | q",
      "code": "module \\$_DFFE_NN1P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C or negedge R) begin\n        if (R == 0)\n            Q <= 1;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFE_NN_": {
      "title": "",
      "ports": "(D, C, E, Q)",
      "source": "simcells.v:622",
      "desc": "A negative edge D-type flip-flop with negative polarity enable.\n::\n\n   Truth table:    D C E | Q\n                  -------+---\n                   d \\ 0 | d\n                   - - - | q",
      "code": "module \\$_DFFE_NN_ (D, C, E, Q);\n    input D, C, E;\n    output reg Q;\n    always @(negedge C) begin\n        if (!E) Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFE_NP0N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:980",
      "desc": "A negative edge D-type flip-flop with positive polarity reset and negative\npolarity clock enable.\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - - 1 - | 0\n                   d \\ - 0 | d\n                   - - - - | q",
      "code": "module \\$_DFFE_NP0N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C or posedge R) begin\n        if (R == 1)\n            Q <= 0;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFE_NP0P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:1004",
      "desc": "A negative edge D-type flip-flop with positive polarity reset and positive\npolarity clock enable.\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - - 1 - | 0\n                   d \\ - 1 | d\n                   - - - - | q",
      "code": "module \\$_DFFE_NP0P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C or posedge R) begin\n        if (R == 1)\n            Q <= 0;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFE_NP1N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:1028",
      "desc": "A negative edge D-type flip-flop with positive polarity set and negative\npolarity clock enable.\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - - 1 - | 1\n                   d \\ - 0 | d\n                   - - - - | q",
      "code": "module \\$_DFFE_NP1N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C or posedge R) begin\n        if (R == 1)\n            Q <= 1;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFE_NP1P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:1052",
      "desc": "A negative edge D-type flip-flop with positive polarity set and positive\npolarity clock enable.\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - - 1 - | 1\n                   d \\ - 1 | d\n                   - - - - | q",
      "code": "module \\$_DFFE_NP1P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C or posedge R) begin\n        if (R == 1)\n            Q <= 1;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFE_NP_": {
      "title": "",
      "ports": "(D, C, E, Q)",
      "source": "simcells.v:641",
      "desc": "A negative edge D-type flip-flop with positive polarity enable.\n::\n\n   Truth table:    D C E | Q\n                  -------+---\n                   d \\ 1 | d\n                   - - - | q",
      "code": "module \\$_DFFE_NP_ (D, C, E, Q);\n    input D, C, E;\n    output reg Q;\n    always @(negedge C) begin\n        if (E) Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFE_PN0N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:1076",
      "desc": "A positive edge D-type flip-flop with negative polarity reset and negative\npolarity clock enable.\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - - 0 - | 0\n                   d / - 0 | d\n                   - - - - | q",
      "code": "module \\$_DFFE_PN0N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C or negedge R) begin\n        if (R == 0)\n            Q <= 0;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFE_PN0P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:1100",
      "desc": "A positive edge D-type flip-flop with negative polarity reset and positive\npolarity clock enable.\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - - 0 - | 0\n                   d / - 1 | d\n                   - - - - | q",
      "code": "module \\$_DFFE_PN0P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C or negedge R) begin\n        if (R == 0)\n            Q <= 0;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFE_PN1N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:1124",
      "desc": "A positive edge D-type flip-flop with negative polarity set and negative\npolarity clock enable.\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - - 0 - | 1\n                   d / - 0 | d\n                   - - - - | q",
      "code": "module \\$_DFFE_PN1N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C or negedge R) begin\n        if (R == 0)\n            Q <= 1;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFE_PN1P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:1148",
      "desc": "A positive edge D-type flip-flop with negative polarity set and positive\npolarity clock enable.\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - - 0 - | 1\n                   d / - 1 | d\n                   - - - - | q",
      "code": "module \\$_DFFE_PN1P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C or negedge R) begin\n        if (R == 0)\n            Q <= 1;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFE_PN_": {
      "title": "",
      "ports": "(D, C, E, Q)",
      "source": "simcells.v:660",
      "desc": "A positive edge D-type flip-flop with negative polarity enable.\n::\n\n   Truth table:    D C E | Q\n                  -------+---\n                   d / 0 | d\n                   - - - | q",
      "code": "module \\$_DFFE_PN_ (D, C, E, Q);\n    input D, C, E;\n    output reg Q;\n    always @(posedge C) begin\n        if (!E) Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFE_PP0N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:1172",
      "desc": "A positive edge D-type flip-flop with positive polarity reset and negative\npolarity clock enable.\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - - 1 - | 0\n                   d / - 0 | d\n                   - - - - | q",
      "code": "module \\$_DFFE_PP0N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C or posedge R) begin\n        if (R == 1)\n            Q <= 0;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFE_PP0P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:1196",
      "desc": "A positive edge D-type flip-flop with positive polarity reset and positive\npolarity clock enable.\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - - 1 - | 0\n                   d / - 1 | d\n                   - - - - | q",
      "code": "module \\$_DFFE_PP0P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C or posedge R) begin\n        if (R == 1)\n            Q <= 0;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFE_PP1N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:1220",
      "desc": "A positive edge D-type flip-flop with positive polarity set and negative\npolarity clock enable.\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - - 1 - | 1\n                   d / - 0 | d\n                   - - - - | q",
      "code": "module \\$_DFFE_PP1N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C or posedge R) begin\n        if (R == 1)\n            Q <= 1;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFE_PP1P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:1244",
      "desc": "A positive edge D-type flip-flop with positive polarity set and positive\npolarity clock enable.\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - - 1 - | 1\n                   d / - 1 | d\n                   - - - - | q",
      "code": "module \\$_DFFE_PP1P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C or posedge R) begin\n        if (R == 1)\n            Q <= 1;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFE_PP_": {
      "title": "",
      "ports": "(D, C, E, Q)",
      "source": "simcells.v:679",
      "desc": "A positive edge D-type flip-flop with positive polarity enable.\n::\n\n   Truth table:    D C E | Q\n                  -------+---\n                   d / 1 | d\n                   - - - | q",
      "code": "module \\$_DFFE_PP_ (D, C, E, Q);\n    input D, C, E;\n    output reg Q;\n    always @(posedge C) begin\n        if (E) Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSRE_NNNN_": {
      "title": "",
      "ports": "(C, S, R, E, D, Q)",
      "source": "simcells.v:1769",
      "desc": "A negative edge D-type flip-flop with negative polarity set, negative\npolarity reset and negative polarity clock enable.\n::\n\n   Truth table:    C S R E D | Q\n                  -----------+---\n                   - - 0 - - | 0\n                   - 0 - - - | 1\n                   \\ - - 0 d | d\n                   - - - - - | q",
      "code": "module \\$_DFFSRE_NNNN_ (C, S, R, E, D, Q);\n    input C, S, R, E, D;\n    output reg Q;\n    always @(negedge C, negedge S, negedge R) begin\n        if (R == 0)\n            Q <= 0;\n        else if (S == 0)\n            Q <= 1;\n            else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSRE_NNNP_": {
      "title": "",
      "ports": "(C, S, R, E, D, Q)",
      "source": "simcells.v:1796",
      "desc": "A negative edge D-type flip-flop with negative polarity set, negative\npolarity reset and positive polarity clock enable.\n::\n\n   Truth table:    C S R E D | Q\n                  -----------+---\n                   - - 0 - - | 0\n                   - 0 - - - | 1\n                   \\ - - 1 d | d\n                   - - - - - | q",
      "code": "module \\$_DFFSRE_NNNP_ (C, S, R, E, D, Q);\n    input C, S, R, E, D;\n    output reg Q;\n    always @(negedge C, negedge S, negedge R) begin\n        if (R == 0)\n            Q <= 0;\n        else if (S == 0)\n            Q <= 1;\n            else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSRE_NNPN_": {
      "title": "",
      "ports": "(C, S, R, E, D, Q)",
      "source": "simcells.v:1823",
      "desc": "A negative edge D-type flip-flop with negative polarity set, positive\npolarity reset and negative polarity clock enable.\n::\n\n   Truth table:    C S R E D | Q\n                  -----------+---\n                   - - 1 - - | 0\n                   - 0 - - - | 1\n                   \\ - - 0 d | d\n                   - - - - - | q",
      "code": "module \\$_DFFSRE_NNPN_ (C, S, R, E, D, Q);\n    input C, S, R, E, D;\n    output reg Q;\n    always @(negedge C, negedge S, posedge R) begin\n        if (R == 1)\n            Q <= 0;\n        else if (S == 0)\n            Q <= 1;\n            else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSRE_NNPP_": {
      "title": "",
      "ports": "(C, S, R, E, D, Q)",
      "source": "simcells.v:1850",
      "desc": "A negative edge D-type flip-flop with negative polarity set, positive\npolarity reset and positive polarity clock enable.\n::\n\n   Truth table:    C S R E D | Q\n                  -----------+---\n                   - - 1 - - | 0\n                   - 0 - - - | 1\n                   \\ - - 1 d | d\n                   - - - - - | q",
      "code": "module \\$_DFFSRE_NNPP_ (C, S, R, E, D, Q);\n    input C, S, R, E, D;\n    output reg Q;\n    always @(negedge C, negedge S, posedge R) begin\n        if (R == 1)\n            Q <= 0;\n        else if (S == 0)\n            Q <= 1;\n            else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSRE_NPNN_": {
      "title": "",
      "ports": "(C, S, R, E, D, Q)",
      "source": "simcells.v:1877",
      "desc": "A negative edge D-type flip-flop with positive polarity set, negative\npolarity reset and negative polarity clock enable.\n::\n\n   Truth table:    C S R E D | Q\n                  -----------+---\n                   - - 0 - - | 0\n                   - 1 - - - | 1\n                   \\ - - 0 d | d\n                   - - - - - | q",
      "code": "module \\$_DFFSRE_NPNN_ (C, S, R, E, D, Q);\n    input C, S, R, E, D;\n    output reg Q;\n    always @(negedge C, posedge S, negedge R) begin\n        if (R == 0)\n            Q <= 0;\n        else if (S == 1)\n            Q <= 1;\n            else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSRE_NPNP_": {
      "title": "",
      "ports": "(C, S, R, E, D, Q)",
      "source": "simcells.v:1904",
      "desc": "A negative edge D-type flip-flop with positive polarity set, negative\npolarity reset and positive polarity clock enable.\n::\n\n   Truth table:    C S R E D | Q\n                  -----------+---\n                   - - 0 - - | 0\n                   - 1 - - - | 1\n                   \\ - - 1 d | d\n                   - - - - - | q",
      "code": "module \\$_DFFSRE_NPNP_ (C, S, R, E, D, Q);\n    input C, S, R, E, D;\n    output reg Q;\n    always @(negedge C, posedge S, negedge R) begin\n        if (R == 0)\n            Q <= 0;\n        else if (S == 1)\n            Q <= 1;\n            else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSRE_NPPN_": {
      "title": "",
      "ports": "(C, S, R, E, D, Q)",
      "source": "simcells.v:1931",
      "desc": "A negative edge D-type flip-flop with positive polarity set, positive\npolarity reset and negative polarity clock enable.\n::\n\n   Truth table:    C S R E D | Q\n                  -----------+---\n                   - - 1 - - | 0\n                   - 1 - - - | 1\n                   \\ - - 0 d | d\n                   - - - - - | q",
      "code": "module \\$_DFFSRE_NPPN_ (C, S, R, E, D, Q);\n    input C, S, R, E, D;\n    output reg Q;\n    always @(negedge C, posedge S, posedge R) begin\n        if (R == 1)\n            Q <= 0;\n        else if (S == 1)\n            Q <= 1;\n            else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSRE_NPPP_": {
      "title": "",
      "ports": "(C, S, R, E, D, Q)",
      "source": "simcells.v:1958",
      "desc": "A negative edge D-type flip-flop with positive polarity set, positive\npolarity reset and positive polarity clock enable.\n::\n\n   Truth table:    C S R E D | Q\n                  -----------+---\n                   - - 1 - - | 0\n                   - 1 - - - | 1\n                   \\ - - 1 d | d\n                   - - - - - | q",
      "code": "module \\$_DFFSRE_NPPP_ (C, S, R, E, D, Q);\n    input C, S, R, E, D;\n    output reg Q;\n    always @(negedge C, posedge S, posedge R) begin\n        if (R == 1)\n            Q <= 0;\n        else if (S == 1)\n            Q <= 1;\n            else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSRE_PNNN_": {
      "title": "",
      "ports": "(C, S, R, E, D, Q)",
      "source": "simcells.v:1985",
      "desc": "A positive edge D-type flip-flop with negative polarity set, negative\npolarity reset and negative polarity clock enable.\n::\n\n   Truth table:    C S R E D | Q\n                  -----------+---\n                   - - 0 - - | 0\n                   - 0 - - - | 1\n                   / - - 0 d | d\n                   - - - - - | q",
      "code": "module \\$_DFFSRE_PNNN_ (C, S, R, E, D, Q);\n    input C, S, R, E, D;\n    output reg Q;\n    always @(posedge C, negedge S, negedge R) begin\n        if (R == 0)\n            Q <= 0;\n        else if (S == 0)\n            Q <= 1;\n            else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSRE_PNNP_": {
      "title": "",
      "ports": "(C, S, R, E, D, Q)",
      "source": "simcells.v:2012",
      "desc": "A positive edge D-type flip-flop with negative polarity set, negative\npolarity reset and positive polarity clock enable.\n::\n\n   Truth table:    C S R E D | Q\n                  -----------+---\n                   - - 0 - - | 0\n                   - 0 - - - | 1\n                   / - - 1 d | d\n                   - - - - - | q",
      "code": "module \\$_DFFSRE_PNNP_ (C, S, R, E, D, Q);\n    input C, S, R, E, D;\n    output reg Q;\n    always @(posedge C, negedge S, negedge R) begin\n        if (R == 0)\n            Q <= 0;\n        else if (S == 0)\n            Q <= 1;\n            else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSRE_PNPN_": {
      "title": "",
      "ports": "(C, S, R, E, D, Q)",
      "source": "simcells.v:2039",
      "desc": "A positive edge D-type flip-flop with negative polarity set, positive\npolarity reset and negative polarity clock enable.\n::\n\n   Truth table:    C S R E D | Q\n                  -----------+---\n                   - - 1 - - | 0\n                   - 0 - - - | 1\n                   / - - 0 d | d\n                   - - - - - | q",
      "code": "module \\$_DFFSRE_PNPN_ (C, S, R, E, D, Q);\n    input C, S, R, E, D;\n    output reg Q;\n    always @(posedge C, negedge S, posedge R) begin\n        if (R == 1)\n            Q <= 0;\n        else if (S == 0)\n            Q <= 1;\n            else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSRE_PNPP_": {
      "title": "",
      "ports": "(C, S, R, E, D, Q)",
      "source": "simcells.v:2066",
      "desc": "A positive edge D-type flip-flop with negative polarity set, positive\npolarity reset and positive polarity clock enable.\n::\n\n   Truth table:    C S R E D | Q\n                  -----------+---\n                   - - 1 - - | 0\n                   - 0 - - - | 1\n                   / - - 1 d | d\n                   - - - - - | q",
      "code": "module \\$_DFFSRE_PNPP_ (C, S, R, E, D, Q);\n    input C, S, R, E, D;\n    output reg Q;\n    always @(posedge C, negedge S, posedge R) begin\n        if (R == 1)\n            Q <= 0;\n        else if (S == 0)\n            Q <= 1;\n            else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSRE_PPNN_": {
      "title": "",
      "ports": "(C, S, R, E, D, Q)",
      "source": "simcells.v:2093",
      "desc": "A positive edge D-type flip-flop with positive polarity set, negative\npolarity reset and negative polarity clock enable.\n::\n\n   Truth table:    C S R E D | Q\n                  -----------+---\n                   - - 0 - - | 0\n                   - 1 - - - | 1\n                   / - - 0 d | d\n                   - - - - - | q",
      "code": "module \\$_DFFSRE_PPNN_ (C, S, R, E, D, Q);\n    input C, S, R, E, D;\n    output reg Q;\n    always @(posedge C, posedge S, negedge R) begin\n        if (R == 0)\n            Q <= 0;\n        else if (S == 1)\n            Q <= 1;\n            else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSRE_PPNP_": {
      "title": "",
      "ports": "(C, S, R, E, D, Q)",
      "source": "simcells.v:2120",
      "desc": "A positive edge D-type flip-flop with positive polarity set, negative\npolarity reset and positive polarity clock enable.\n::\n\n   Truth table:    C S R E D | Q\n                  -----------+---\n                   - - 0 - - | 0\n                   - 1 - - - | 1\n                   / - - 1 d | d\n                   - - - - - | q",
      "code": "module \\$_DFFSRE_PPNP_ (C, S, R, E, D, Q);\n    input C, S, R, E, D;\n    output reg Q;\n    always @(posedge C, posedge S, negedge R) begin\n        if (R == 0)\n            Q <= 0;\n        else if (S == 1)\n            Q <= 1;\n            else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSRE_PPPN_": {
      "title": "",
      "ports": "(C, S, R, E, D, Q)",
      "source": "simcells.v:2147",
      "desc": "A positive edge D-type flip-flop with positive polarity set, positive\npolarity reset and negative polarity clock enable.\n::\n\n   Truth table:    C S R E D | Q\n                  -----------+---\n                   - - 1 - - | 0\n                   - 1 - - - | 1\n                   / - - 0 d | d\n                   - - - - - | q",
      "code": "module \\$_DFFSRE_PPPN_ (C, S, R, E, D, Q);\n    input C, S, R, E, D;\n    output reg Q;\n    always @(posedge C, posedge S, posedge R) begin\n        if (R == 1)\n            Q <= 0;\n        else if (S == 1)\n            Q <= 1;\n            else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSRE_PPPP_": {
      "title": "",
      "ports": "(C, S, R, E, D, Q)",
      "source": "simcells.v:2174",
      "desc": "A positive edge D-type flip-flop with positive polarity set, positive\npolarity reset and positive polarity clock enable.\n::\n\n   Truth table:    C S R E D | Q\n                  -----------+---\n                   - - 1 - - | 0\n                   - 1 - - - | 1\n                   / - - 1 d | d\n                   - - - - - | q",
      "code": "module \\$_DFFSRE_PPPP_ (C, S, R, E, D, Q);\n    input C, S, R, E, D;\n    output reg Q;\n    always @(posedge C, posedge S, posedge R) begin\n        if (R == 1)\n            Q <= 0;\n        else if (S == 1)\n            Q <= 1;\n            else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSR_NNN_": {
      "title": "",
      "ports": "(C, S, R, D, Q)",
      "source": "simcells.v:1553",
      "desc": "A negative edge D-type flip-flop with negative polarity set and negative\npolarity reset.\n::\n\n   Truth table:    C S R D | Q\n                  ---------+---\n                   - - 0 - | 0\n                   - 0 - - | 1\n                   \\ - - d | d\n                   - - - - | q",
      "code": "module \\$_DFFSR_NNN_ (C, S, R, D, Q);\n    input C, S, R, D;\n    output reg Q;\n    always @(negedge C, negedge S, negedge R) begin\n        if (R == 0)\n            Q <= 0;\n        else if (S == 0)\n            Q <= 1;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSR_NNP_": {
      "title": "",
      "ports": "(C, S, R, D, Q)",
      "source": "simcells.v:1580",
      "desc": "A negative edge D-type flip-flop with negative polarity set and positive\npolarity reset.\n::\n\n   Truth table:    C S R D | Q\n                  ---------+---\n                   - - 1 - | 0\n                   - 0 - - | 1\n                   \\ - - d | d\n                   - - - - | q",
      "code": "module \\$_DFFSR_NNP_ (C, S, R, D, Q);\n    input C, S, R, D;\n    output reg Q;\n    always @(negedge C, negedge S, posedge R) begin\n        if (R == 1)\n            Q <= 0;\n        else if (S == 0)\n            Q <= 1;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSR_NPN_": {
      "title": "",
      "ports": "(C, S, R, D, Q)",
      "source": "simcells.v:1607",
      "desc": "A negative edge D-type flip-flop with positive polarity set and negative\npolarity reset.\n::\n\n   Truth table:    C S R D | Q\n                  ---------+---\n                   - - 0 - | 0\n                   - 1 - - | 1\n                   \\ - - d | d\n                   - - - - | q",
      "code": "module \\$_DFFSR_NPN_ (C, S, R, D, Q);\n    input C, S, R, D;\n    output reg Q;\n    always @(negedge C, posedge S, negedge R) begin\n        if (R == 0)\n            Q <= 0;\n        else if (S == 1)\n            Q <= 1;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSR_NPP_": {
      "title": "",
      "ports": "(C, S, R, D, Q)",
      "source": "simcells.v:1634",
      "desc": "A negative edge D-type flip-flop with positive polarity set and positive\npolarity reset.\n::\n\n   Truth table:    C S R D | Q\n                  ---------+---\n                   - - 1 - | 0\n                   - 1 - - | 1\n                   \\ - - d | d\n                   - - - - | q",
      "code": "module \\$_DFFSR_NPP_ (C, S, R, D, Q);\n    input C, S, R, D;\n    output reg Q;\n    always @(negedge C, posedge S, posedge R) begin\n        if (R == 1)\n            Q <= 0;\n        else if (S == 1)\n            Q <= 1;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSR_PNN_": {
      "title": "",
      "ports": "(C, S, R, D, Q)",
      "source": "simcells.v:1661",
      "desc": "A positive edge D-type flip-flop with negative polarity set and negative\npolarity reset.\n::\n\n   Truth table:    C S R D | Q\n                  ---------+---\n                   - - 0 - | 0\n                   - 0 - - | 1\n                   / - - d | d\n                   - - - - | q",
      "code": "module \\$_DFFSR_PNN_ (C, S, R, D, Q);\n    input C, S, R, D;\n    output reg Q;\n    always @(posedge C, negedge S, negedge R) begin\n        if (R == 0)\n            Q <= 0;\n        else if (S == 0)\n            Q <= 1;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSR_PNP_": {
      "title": "",
      "ports": "(C, S, R, D, Q)",
      "source": "simcells.v:1688",
      "desc": "A positive edge D-type flip-flop with negative polarity set and positive\npolarity reset.\n::\n\n   Truth table:    C S R D | Q\n                  ---------+---\n                   - - 1 - | 0\n                   - 0 - - | 1\n                   / - - d | d\n                   - - - - | q",
      "code": "module \\$_DFFSR_PNP_ (C, S, R, D, Q);\n    input C, S, R, D;\n    output reg Q;\n    always @(posedge C, negedge S, posedge R) begin\n        if (R == 1)\n            Q <= 0;\n        else if (S == 0)\n            Q <= 1;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSR_PPN_": {
      "title": "",
      "ports": "(C, S, R, D, Q)",
      "source": "simcells.v:1715",
      "desc": "A positive edge D-type flip-flop with positive polarity set and negative\npolarity reset.\n::\n\n   Truth table:    C S R D | Q\n                  ---------+---\n                   - - 0 - | 0\n                   - 1 - - | 1\n                   / - - d | d\n                   - - - - | q",
      "code": "module \\$_DFFSR_PPN_ (C, S, R, D, Q);\n    input C, S, R, D;\n    output reg Q;\n    always @(posedge C, posedge S, negedge R) begin\n        if (R == 0)\n            Q <= 0;\n        else if (S == 1)\n            Q <= 1;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFFSR_PPP_": {
      "title": "",
      "ports": "(C, S, R, D, Q)",
      "source": "simcells.v:1742",
      "desc": "A positive edge D-type flip-flop with positive polarity set and positive\npolarity reset.\n::\n\n   Truth table:    C S R D | Q\n                  ---------+---\n                   - - 1 - | 0\n                   - 1 - - | 1\n                   / - - d | d\n                   - - - - | q",
      "code": "module \\$_DFFSR_PPP_ (C, S, R, D, Q);\n    input C, S, R, D;\n    output reg Q;\n    always @(posedge C, posedge S, posedge R) begin\n        if (R == 1)\n            Q <= 0;\n        else if (S == 1)\n            Q <= 1;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\S", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFF_NN0_": {
      "title": "",
      "ports": "(D, C, R, Q)",
      "source": "simcells.v:699",
      "desc": "A negative edge D-type flip-flop with negative polarity reset.\n::\n\n   Truth table:    D C R | Q\n                  -------+---\n                   - - 0 | 0\n                   d \\ - | d\n                   - - - | q",
      "code": "module \\$_DFF_NN0_ (D, C, R, Q);\n    input D, C, R;\n    output reg Q;\n    always @(negedge C or negedge R) begin\n        if (R == 0)\n            Q <= 0;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFF_NN1_": {
      "title": "",
      "ports": "(D, C, R, Q)",
      "source": "simcells.v:722",
      "desc": "A negative edge D-type flip-flop with negative polarity set.\n::\n\n   Truth table:    D C R | Q\n                  -------+---\n                   - - 0 | 1\n                   d \\ - | d\n                   - - - | q",
      "code": "module \\$_DFF_NN1_ (D, C, R, Q);\n    input D, C, R;\n    output reg Q;\n    always @(negedge C or negedge R) begin\n        if (R == 0)\n            Q <= 1;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFF_NP0_": {
      "title": "",
      "ports": "(D, C, R, Q)",
      "source": "simcells.v:745",
      "desc": "A negative edge D-type flip-flop with positive polarity reset.\n::\n\n   Truth table:    D C R | Q\n                  -------+---\n                   - - 1 | 0\n                   d \\ - | d\n                   - - - | q",
      "code": "module \\$_DFF_NP0_ (D, C, R, Q);\n    input D, C, R;\n    output reg Q;\n    always @(negedge C or posedge R) begin\n        if (R == 1)\n            Q <= 0;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFF_NP1_": {
      "title": "",
      "ports": "(D, C, R, Q)",
      "source": "simcells.v:768",
      "desc": "A negative edge D-type flip-flop with positive polarity set.\n::\n\n   Truth table:    D C R | Q\n                  -------+---\n                   - - 1 | 1\n                   d \\ - | d\n                   - - - | q",
      "code": "module \\$_DFF_NP1_ (D, C, R, Q);\n    input D, C, R;\n    output reg Q;\n    always @(negedge C or posedge R) begin\n        if (R == 1)\n            Q <= 1;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFF_N_": {
      "title": "",
      "ports": "(D, C, Q)",
      "source": "simcells.v:584",
      "desc": "A negative edge D-type flip-flop.\n::\n\n   Truth table:    D C | Q\n                  -----+---\n                   d \\ | d\n                   - - | q",
      "code": "module \\$_DFF_N_ (D, C, Q);\n    input D, C;\n    output reg Q;\n    always @(negedge C) begin\n        Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFF_PN0_": {
      "title": "",
      "ports": "(D, C, R, Q)",
      "source": "simcells.v:791",
      "desc": "A positive edge D-type flip-flop with negative polarity reset.\n::\n\n   Truth table:    D C R | Q\n                  -------+---\n                   - - 0 | 0\n                   d / - | d\n                   - - - | q",
      "code": "module \\$_DFF_PN0_ (D, C, R, Q);\n    input D, C, R;\n    output reg Q;\n    always @(posedge C or negedge R) begin\n        if (R == 0)\n            Q <= 0;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFF_PN1_": {
      "title": "",
      "ports": "(D, C, R, Q)",
      "source": "simcells.v:814",
      "desc": "A positive edge D-type flip-flop with negative polarity set.\n::\n\n   Truth table:    D C R | Q\n                  -------+---\n                   - - 0 | 1\n                   d / - | d\n                   - - - | q",
      "code": "module \\$_DFF_PN1_ (D, C, R, Q);\n    input D, C, R;\n    output reg Q;\n    always @(posedge C or negedge R) begin\n        if (R == 0)\n            Q <= 1;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFF_PP0_": {
      "title": "",
      "ports": "(D, C, R, Q)",
      "source": "simcells.v:837",
      "desc": "A positive edge D-type flip-flop with positive polarity reset.\n::\n\n   Truth table:    D C R | Q\n                  -------+---\n                   - - 1 | 0\n                   d / - | d\n                   - - - | q",
      "code": "module \\$_DFF_PP0_ (D, C, R, Q);\n    input D, C, R;\n    output reg Q;\n    always @(posedge C or posedge R) begin\n        if (R == 1)\n            Q <= 0;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFF_PP1_": {
      "title": "",
      "ports": "(D, C, R, Q)",
      "source": "simcells.v:860",
      "desc": "A positive edge D-type flip-flop with positive polarity set.\n::\n\n   Truth table:    D C R | Q\n                  -------+---\n                   - - 1 | 1\n                   d / - | d\n                   - - - | q",
      "code": "module \\$_DFF_PP1_ (D, C, R, Q);\n    input D, C, R;\n    output reg Q;\n    always @(posedge C or posedge R) begin\n        if (R == 1)\n            Q <= 1;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DFF_P_": {
      "title": "",
      "ports": "(D, C, Q)",
      "source": "simcells.v:603",
      "desc": "A positive edge D-type flip-flop.\n::\n\n   Truth table:    D C | Q\n                  -----+---\n                   d / | d\n                   - - | q",
      "code": "module \\$_DFF_P_ (D, C, Q);\n    input D, C;\n    output reg Q;\n    always @(posedge C) begin\n        Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DLATCHSR_NNN_": {
      "title": "",
      "ports": "(E, S, R, D, Q)",
      "source": "simcells.v:3409",
      "desc": "A negative enable D-type latch with negative polarity set and negative\npolarity reset.\n::\n\n   Truth table:    E S R D | Q\n                  ---------+---\n                   - - 0 - | 0\n                   - 0 - - | 1\n                   0 - - d | d\n                   - - - - | q",
      "code": "module \\$_DLATCHSR_NNN_ (E, S, R, D, Q);\n    input E, S, R, D;\n    output reg Q;\n    always @* begin\n        if (R == 0)\n            Q <= 0;\n        else if (S == 0)\n            Q <= 1;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\S", "\\E"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DLATCHSR_NNP_": {
      "title": "",
      "ports": "(E, S, R, D, Q)",
      "source": "simcells.v:3436",
      "desc": "A negative enable D-type latch with negative polarity set and positive\npolarity reset.\n::\n\n   Truth table:    E S R D | Q\n                  ---------+---\n                   - - 1 - | 0\n                   - 0 - - | 1\n                   0 - - d | d\n                   - - - - | q",
      "code": "module \\$_DLATCHSR_NNP_ (E, S, R, D, Q);\n    input E, S, R, D;\n    output reg Q;\n    always @* begin\n        if (R == 1)\n            Q <= 0;\n        else if (S == 0)\n            Q <= 1;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\S", "\\E"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DLATCHSR_NPN_": {
      "title": "",
      "ports": "(E, S, R, D, Q)",
      "source": "simcells.v:3463",
      "desc": "A negative enable D-type latch with positive polarity set and negative\npolarity reset.\n::\n\n   Truth table:    E S R D | Q\n                  ---------+---\n                   - - 0 - | 0\n                   - 1 - - | 1\n                   0 - - d | d\n                   - - - - | q",
      "code": "module \\$_DLATCHSR_NPN_ (E, S, R, D, Q);\n    input E, S, R, D;\n    output reg Q;\n    always @* begin\n        if (R == 0)\n            Q <= 0;\n        else if (S == 1)\n            Q <= 1;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\S", "\\E"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DLATCHSR_NPP_": {
      "title": "",
      "ports": "(E, S, R, D, Q)",
      "source": "simcells.v:3490",
      "desc": "A negative enable D-type latch with positive polarity set and positive\npolarity reset.\n::\n\n   Truth table:    E S R D | Q\n                  ---------+---\n                   - - 1 - | 0\n                   - 1 - - | 1\n                   0 - - d | d\n                   - - - - | q",
      "code": "module \\$_DLATCHSR_NPP_ (E, S, R, D, Q);\n    input E, S, R, D;\n    output reg Q;\n    always @* begin\n        if (R == 1)\n            Q <= 0;\n        else if (S == 1)\n            Q <= 1;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\S", "\\E"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DLATCHSR_PNN_": {
      "title": "",
      "ports": "(E, S, R, D, Q)",
      "source": "simcells.v:3517",
      "desc": "A positive enable D-type latch with negative polarity set and negative\npolarity reset.\n::\n\n   Truth table:    E S R D | Q\n                  ---------+---\n                   - - 0 - | 0\n                   - 0 - - | 1\n                   1 - - d | d\n                   - - - - | q",
      "code": "module \\$_DLATCHSR_PNN_ (E, S, R, D, Q);\n    input E, S, R, D;\n    output reg Q;\n    always @* begin\n        if (R == 0)\n            Q <= 0;\n        else if (S == 0)\n            Q <= 1;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\S", "\\E"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DLATCHSR_PNP_": {
      "title": "",
      "ports": "(E, S, R, D, Q)",
      "source": "simcells.v:3544",
      "desc": "A positive enable D-type latch with negative polarity set and positive\npolarity reset.\n::\n\n   Truth table:    E S R D | Q\n                  ---------+---\n                   - - 1 - | 0\n                   - 0 - - | 1\n                   1 - - d | d\n                   - - - - | q",
      "code": "module \\$_DLATCHSR_PNP_ (E, S, R, D, Q);\n    input E, S, R, D;\n    output reg Q;\n    always @* begin\n        if (R == 1)\n            Q <= 0;\n        else if (S == 0)\n            Q <= 1;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\S", "\\E"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DLATCHSR_PPN_": {
      "title": "",
      "ports": "(E, S, R, D, Q)",
      "source": "simcells.v:3571",
      "desc": "A positive enable D-type latch with positive polarity set and negative\npolarity reset.\n::\n\n   Truth table:    E S R D | Q\n                  ---------+---\n                   - - 0 - | 0\n                   - 1 - - | 1\n                   1 - - d | d\n                   - - - - | q",
      "code": "module \\$_DLATCHSR_PPN_ (E, S, R, D, Q);\n    input E, S, R, D;\n    output reg Q;\n    always @* begin\n        if (R == 0)\n            Q <= 0;\n        else if (S == 1)\n            Q <= 1;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\S", "\\E"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DLATCHSR_PPP_": {
      "title": "",
      "ports": "(E, S, R, D, Q)",
      "source": "simcells.v:3598",
      "desc": "A positive enable D-type latch with positive polarity set and positive\npolarity reset.\n::\n\n   Truth table:    E S R D | Q\n                  ---------+---\n                   - - 1 - | 0\n                   - 1 - - | 1\n                   1 - - d | d\n                   - - - - | q",
      "code": "module \\$_DLATCHSR_PPP_ (E, S, R, D, Q);\n    input E, S, R, D;\n    output reg Q;\n    always @* begin\n        if (R == 1)\n            Q <= 0;\n        else if (S == 1)\n            Q <= 1;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\S", "\\E"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DLATCH_NN0_": {
      "title": "",
      "ports": "(E, R, D, Q)",
      "source": "simcells.v:3223",
      "desc": "A negative enable D-type latch with negative polarity reset.\n::\n\n   Truth table:    E R D | Q\n                  -------+---\n                   - 0 - | 0\n                   0 - d | d\n                   - - - | q",
      "code": "module \\$_DLATCH_NN0_ (E, R, D, Q);\n    input E, R, D;\n    output reg Q;\n    always @* begin\n        if (R == 0)\n                    Q <= 0;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\E"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DLATCH_NN1_": {
      "title": "",
      "ports": "(E, R, D, Q)",
      "source": "simcells.v:3246",
      "desc": "A negative enable D-type latch with negative polarity set.\n::\n\n   Truth table:    E R D | Q\n                  -------+---\n                   - 0 - | 1\n                   0 - d | d\n                   - - - | q",
      "code": "module \\$_DLATCH_NN1_ (E, R, D, Q);\n    input E, R, D;\n    output reg Q;\n    always @* begin\n        if (R == 0)\n                    Q <= 1;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\E"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DLATCH_NP0_": {
      "title": "",
      "ports": "(E, R, D, Q)",
      "source": "simcells.v:3269",
      "desc": "A negative enable D-type latch with positive polarity reset.\n::\n\n   Truth table:    E R D | Q\n                  -------+---\n                   - 1 - | 0\n                   0 - d | d\n                   - - - | q",
      "code": "module \\$_DLATCH_NP0_ (E, R, D, Q);\n    input E, R, D;\n    output reg Q;\n    always @* begin\n        if (R == 1)\n                    Q <= 0;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\E"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DLATCH_NP1_": {
      "title": "",
      "ports": "(E, R, D, Q)",
      "source": "simcells.v:3292",
      "desc": "A negative enable D-type latch with positive polarity set.\n::\n\n   Truth table:    E R D | Q\n                  -------+---\n                   - 1 - | 1\n                   0 - d | d\n                   - - - | q",
      "code": "module \\$_DLATCH_NP1_ (E, R, D, Q);\n    input E, R, D;\n    output reg Q;\n    always @* begin\n        if (R == 1)\n                    Q <= 1;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\E"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DLATCH_N_": {
      "title": "",
      "ports": "(E, D, Q)",
      "source": "simcells.v:3182",
      "desc": "A negative enable D-type latch.\n::\n\n   Truth table:    E D | Q\n                  -----+---\n                   0 d | d\n                   - - | q",
      "code": "module \\$_DLATCH_N_ (E, D, Q);\n    input E, D;\n    output reg Q;\n    always @* begin\n        if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\E"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DLATCH_PN0_": {
      "title": "",
      "ports": "(E, R, D, Q)",
      "source": "simcells.v:3315",
      "desc": "A positive enable D-type latch with negative polarity reset.\n::\n\n   Truth table:    E R D | Q\n                  -------+---\n                   - 0 - | 0\n                   1 - d | d\n                   - - - | q",
      "code": "module \\$_DLATCH_PN0_ (E, R, D, Q);\n    input E, R, D;\n    output reg Q;\n    always @* begin\n        if (R == 0)\n                    Q <= 0;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\E"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DLATCH_PN1_": {
      "title": "",
      "ports": "(E, R, D, Q)",
      "source": "simcells.v:3338",
      "desc": "A positive enable D-type latch with negative polarity set.\n::\n\n   Truth table:    E R D | Q\n                  -------+---\n                   - 0 - | 1\n                   1 - d | d\n                   - - - | q",
      "code": "module \\$_DLATCH_PN1_ (E, R, D, Q);\n    input E, R, D;\n    output reg Q;\n    always @* begin\n        if (R == 0)\n                    Q <= 1;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\E"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DLATCH_PP0_": {
      "title": "",
      "ports": "(E, R, D, Q)",
      "source": "simcells.v:3361",
      "desc": "A positive enable D-type latch with positive polarity reset.\n::\n\n   Truth table:    E R D | Q\n                  -------+---\n                   - 1 - | 0\n                   1 - d | d\n                   - - - | q",
      "code": "module \\$_DLATCH_PP0_ (E, R, D, Q);\n    input E, R, D;\n    output reg Q;\n    always @* begin\n        if (R == 1)\n                    Q <= 0;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\E"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DLATCH_PP1_": {
      "title": "",
      "ports": "(E, R, D, Q)",
      "source": "simcells.v:3384",
      "desc": "A positive enable D-type latch with positive polarity set.\n::\n\n   Truth table:    E R D | Q\n                  -------+---\n                   - 1 - | 1\n                   1 - d | d\n                   - - - | q",
      "code": "module \\$_DLATCH_PP1_ (E, R, D, Q);\n    input E, R, D;\n    output reg Q;\n    always @* begin\n        if (R == 1)\n                    Q <= 1;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\E"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_DLATCH_P_": {
      "title": "",
      "ports": "(E, D, Q)",
      "source": "simcells.v:3202",
      "desc": "A positive enable D-type latch.\n::\n\n   Truth table:    E D | Q\n                  -----+---\n                   1 d | d\n                   - - | q",
      "code": "module \\$_DLATCH_P_ (E, D, Q);\n    input E, D;\n    output reg Q;\n    always @* begin\n        if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\E"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_FF_": {
      "title": "",
      "ports": "(D, Q)",
      "source": "simcells.v:564",
      "desc": "A D-type flip-flop that is clocked from the implicit global clock. (This cell\ntype is usually only used in netlists for formal verification.)",
      "code": "module \\$_FF_ (D, Q);\n    input D;\n    output reg Q;\n    always @($global_clock) begin\n        Q <= D;\n    end\nendmodule",
      "inputs": ["\\D"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_MUX16_": {
      "title": "",
      "ports": "(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, S, T, U, V, Y)",
      "source": "simcells.v:321",
      "desc": "A 16-input MUX gate.\n::\n\n   Truth table:    A B C D E F G H I J K L M N O P S T U V | Y\n                  -----------------------------------------+---\n                   a - - - - - - - - - - - - - - - 0 0 0 0 | a\n                   - b - - - - - - - - - - - - - - 1 0 0 0 | b\n                   - - c - - - - - - - - - - - - - 0 1 0 0 | c\n                   - - - d - - - - - - - - - - - - 1 1 0 0 | d\n                   - - - - e - - - - - - - - - - - 0 0 1 0 | e\n                   - - - - - f - - - - - - - - - - 1 0 1 0 | f\n                   - - - - - - g - - - - - - - - - 0 1 1 0 | g\n                   - - - - - - - h - - - - - - - - 1 1 1 0 | h\n                   - - - - - - - - i - - - - - - - 0 0 0 1 | i\n                   - - - - - - - - - j - - - - - - 1 0 0 1 | j\n                   - - - - - - - - - - k - - - - - 0 1 0 1 | k\n                   - - - - - - - - - - - l - - - - 1 1 0 1 | l\n                   - - - - - - - - - - - - m - - - 0 0 1 1 | m\n                   - - - - - - - - - - - - - n - - 1 0 1 1 | n\n                   - - - - - - - - - - - - - - o - 0 1 1 1 | o\n                   - - - - - - - - - - - - - - - p 1 1 1 1 | p",
      "code": "module \\$_MUX16_ (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, S, T, U, V, Y);\n    input A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, S, T, U, V;\n    output Y;\n    assign Y = V ? U ? T ? (S ? P : O) :\n                           (S ? N : M) :\n                       T ? (S ? L : K) :\n                           (S ? J : I) :\n                   U ? T ? (S ? H : G) :\n                           (S ? F : E) :\n                       T ? (S ? D : C) :\n                           (S ? B : A);\nendmodule",
      "inputs": ["\\V", "\\U", "\\T", "\\S", "\\P", "\\O", "\\N", "\\M", "\\L", "\\K", "\\J", "\\I", "\\H", "\\G", "\\F", "\\E", "\\D", "\\C", "\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$_MUX4_": {
      "title": "",
      "ports": "(A, B, C, D, S, T, Y)",
      "source": "simcells.v:263",
      "desc": "A 4-input MUX gate.\n::\n\n   Truth table:    A B C D S T | Y\n                  -------------+---\n                   a - - - 0 0 | a\n                   - b - - 1 0 | b\n                   - - c - 0 1 | c\n                   - - - d 1 1 | d",
      "code": "module \\$_MUX4_ (A, B, C, D, S, T, Y);\n    input A, B, C, D, S, T;\n    output Y;\n    assign Y = T ? (S ? D : C) :\n                   (S ? B : A);\nendmodule",
      "inputs": ["\\T", "\\S", "\\D", "\\C", "\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$_MUX8_": {
      "title": "",
      "ports": "(A, B, C, D, E, F, G, H, S, T, U, Y)",
      "source": "simcells.v:287",
      "desc": "An 8-input MUX gate.\n::\n\n   Truth table:    A B C D E F G H S T U | Y\n                  -----------------------+---\n                   a - - - - - - - 0 0 0 | a\n                   - b - - - - - - 1 0 0 | b\n                   - - c - - - - - 0 1 0 | c\n                   - - - d - - - - 1 1 0 | d\n                   - - - - e - - - 0 0 1 | e\n                   - - - - - f - - 1 0 1 | f\n                   - - - - - - g - 0 1 1 | g\n                   - - - - - - - h 1 1 1 | h",
      "code": "module \\$_MUX8_ (A, B, C, D, E, F, G, H, S, T, U, Y);\n    input A, B, C, D, E, F, G, H, S, T, U;\n    output Y;\n    assign Y = U ? T ? (S ? H : G) :\n                       (S ? F : E) :\n                   T ? (S ? D : C) :\n                       (S ? B : A);\nendmodule",
      "inputs": ["\\U", "\\T", "\\S", "\\H", "\\G", "\\F", "\\E", "\\D", "\\C", "\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$_MUX_": {
      "title": "",
      "ports": "(A, B, S, Y)",
      "source": "simcells.v:225",
      "desc": "A 2-input MUX gate.\n::\n\n   Truth table:    A B S | Y\n                  -------+---\n                   a - 0 | a\n                   - b 1 | b",
      "code": "module \\$_MUX_ (A, B, S, Y);\n    input A, B, S;\n    output Y;\n    assign Y = S ? B : A;\nendmodule",
      "inputs": ["\\S", "\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$_NAND_": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simcells.v:94",
      "desc": "A 2-input NAND gate.\n::\n\n   Truth table:    A B | Y\n                  -----+---\n                   0 0 | 1\n                   0 1 | 1\n                   1 0 | 1\n                   1 1 | 0",
      "code": "module \\$_NAND_ (A, B, Y);\n    input A, B;\n    output Y;\n    assign Y = ~(A & B);\nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$_NMUX_": {
      "title": "",
      "ports": "(A, B, S, Y)",
      "source": "simcells.v:244",
      "desc": "A 2-input inverting MUX gate.\n::\n\n   Truth table:    A B S | Y\n                  -------+---\n                   0 - 0 | 1\n                   1 - 0 | 0\n                   - 0 1 | 1\n                   - 1 1 | 0",
      "code": "module \\$_NMUX_ (A, B, S, Y);\n    input A, B, S;\n    output Y;\n    assign Y = S ? !B : !A;\nendmodule",
      "inputs": ["\\S", "\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$_NOR_": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simcells.v:132",
      "desc": "A 2-input NOR gate.\n::\n\n   Truth table:    A B | Y\n                  -----+---\n                   0 0 | 1\n                   0 1 | 0\n                   1 0 | 0\n                   1 1 | 0",
      "code": "module \\$_NOR_ (A, B, Y);\n    input A, B;\n    output Y;\n    assign Y = ~(A | B);\nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$_NOT_": {
      "title": "",
      "ports": "(A, Y)",
      "source": "simcells.v:56",
      "desc": "An inverter gate.\n::\n\n   Truth table:    A | Y\n                  ---+---\n                   0 | 1\n                   1 | 0",
      "code": "module \\$_NOT_ (A, Y);\n    input A;\n    output Y;\n    assign Y = ~A;\nendmodule",
      "inputs": ["\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$_OAI3_": {
      "title": "",
      "ports": "(A, B, C, Y)",
      "source": "simcells.v:374",
      "desc": "A 3-input Or-And-Invert gate.\n::\n\n   Truth table:    A B C | Y\n                  -------+---\n                   0 0 0 | 1\n                   0 0 1 | 1\n                   0 1 0 | 1\n                   0 1 1 | 0\n                   1 0 0 | 1\n                   1 0 1 | 0\n                   1 1 0 | 1\n                   1 1 1 | 0",
      "code": "module \\$_OAI3_ (A, B, C, Y);\n    input A, B, C;\n    output Y;\n    assign Y = ~((A | B) & C);\nendmodule",
      "inputs": ["\\C", "\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$_OAI4_": {
      "title": "",
      "ports": "(A, B, C, D, Y)",
      "source": "simcells.v:436",
      "desc": "A 4-input Or-And-Invert gate.\n::\n\n   Truth table:    A B C D | Y\n                  ---------+---\n                   0 0 0 0 | 1\n                   0 0 0 1 | 1\n                   0 0 1 0 | 1\n                   0 0 1 1 | 1\n                   0 1 0 0 | 1\n                   0 1 0 1 | 0\n                   0 1 1 0 | 0\n                   0 1 1 1 | 0\n                   1 0 0 0 | 1\n                   1 0 0 1 | 0\n                   1 0 1 0 | 0\n                   1 0 1 1 | 0\n                   1 1 0 0 | 1\n                   1 1 0 1 | 0\n                   1 1 1 0 | 0\n                   1 1 1 1 | 0",
      "code": "module \\$_OAI4_ (A, B, C, D, Y);\n    input A, B, C, D;\n    output Y;\n    assign Y = ~((A | B) & (C | D));\nendmodule",
      "inputs": ["\\D", "\\C", "\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$_ORNOT_": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simcells.v:208",
      "desc": "A 2-input OR-NOT gate.\n::\n\n   Truth table:    A B | Y\n                  -----+---\n                   0 0 | 1\n                   0 1 | 0\n                   1 0 | 1\n                   1 1 | 1",
      "code": "module \\$_ORNOT_ (A, B, Y);\n    input A, B;\n    output Y;\n    assign Y = A | (~B);\nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$_OR_": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simcells.v:113",
      "desc": "A 2-input OR gate.\n::\n\n   Truth table:    A B | Y\n                  -----+---\n                   0 0 | 0\n                   0 1 | 1\n                   1 0 | 1\n                   1 1 | 1",
      "code": "module \\$_OR_ (A, B, Y);\n    input A, B;\n    output Y;\n    assign Y = A | B;\nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$_SDFFCE_NN0N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2768",
      "desc": "A negative edge D-type flip-flop with negative polarity synchronous reset and negative\npolarity clock enable (with clock enable having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - \\ 0 0 | 0\n                   d \\ - 0 | d\n                   - - - - | q",
      "code": "module \\$_SDFFCE_NN0N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C) begin\n        if (E == 0) begin\n            if (R == 0)\n                Q <= 0;\n            else\n                Q <= D;\n        end\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFCE_NN0P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2794",
      "desc": "A negative edge D-type flip-flop with negative polarity synchronous reset and positive\npolarity clock enable (with clock enable having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - \\ 0 1 | 0\n                   d \\ - 1 | d\n                   - - - - | q",
      "code": "module \\$_SDFFCE_NN0P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C) begin\n        if (E == 1) begin\n            if (R == 0)\n                Q <= 0;\n            else\n                Q <= D;\n        end\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFCE_NN1N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2820",
      "desc": "A negative edge D-type flip-flop with negative polarity synchronous set and negative\npolarity clock enable (with clock enable having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - \\ 0 0 | 1\n                   d \\ - 0 | d\n                   - - - - | q",
      "code": "module \\$_SDFFCE_NN1N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C) begin\n        if (E == 0) begin\n            if (R == 0)\n                Q <= 1;\n            else\n                Q <= D;\n        end\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFCE_NN1P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2846",
      "desc": "A negative edge D-type flip-flop with negative polarity synchronous set and positive\npolarity clock enable (with clock enable having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - \\ 0 1 | 1\n                   d \\ - 1 | d\n                   - - - - | q",
      "code": "module \\$_SDFFCE_NN1P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C) begin\n        if (E == 1) begin\n            if (R == 0)\n                Q <= 1;\n            else\n                Q <= D;\n        end\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFCE_NP0N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2872",
      "desc": "A negative edge D-type flip-flop with positive polarity synchronous reset and negative\npolarity clock enable (with clock enable having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - \\ 1 0 | 0\n                   d \\ - 0 | d\n                   - - - - | q",
      "code": "module \\$_SDFFCE_NP0N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C) begin\n        if (E == 0) begin\n            if (R == 1)\n                Q <= 0;\n            else\n                Q <= D;\n        end\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFCE_NP0P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2898",
      "desc": "A negative edge D-type flip-flop with positive polarity synchronous reset and positive\npolarity clock enable (with clock enable having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - \\ 1 1 | 0\n                   d \\ - 1 | d\n                   - - - - | q",
      "code": "module \\$_SDFFCE_NP0P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C) begin\n        if (E == 1) begin\n            if (R == 1)\n                Q <= 0;\n            else\n                Q <= D;\n        end\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFCE_NP1N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2924",
      "desc": "A negative edge D-type flip-flop with positive polarity synchronous set and negative\npolarity clock enable (with clock enable having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - \\ 1 0 | 1\n                   d \\ - 0 | d\n                   - - - - | q",
      "code": "module \\$_SDFFCE_NP1N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C) begin\n        if (E == 0) begin\n            if (R == 1)\n                Q <= 1;\n            else\n                Q <= D;\n        end\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFCE_NP1P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2950",
      "desc": "A negative edge D-type flip-flop with positive polarity synchronous set and positive\npolarity clock enable (with clock enable having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - \\ 1 1 | 1\n                   d \\ - 1 | d\n                   - - - - | q",
      "code": "module \\$_SDFFCE_NP1P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C) begin\n        if (E == 1) begin\n            if (R == 1)\n                Q <= 1;\n            else\n                Q <= D;\n        end\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFCE_PN0N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2976",
      "desc": "A positive edge D-type flip-flop with negative polarity synchronous reset and negative\npolarity clock enable (with clock enable having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - / 0 0 | 0\n                   d / - 0 | d\n                   - - - - | q",
      "code": "module \\$_SDFFCE_PN0N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C) begin\n        if (E == 0) begin\n            if (R == 0)\n                Q <= 0;\n            else\n                Q <= D;\n        end\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFCE_PN0P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:3002",
      "desc": "A positive edge D-type flip-flop with negative polarity synchronous reset and positive\npolarity clock enable (with clock enable having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - / 0 1 | 0\n                   d / - 1 | d\n                   - - - - | q",
      "code": "module \\$_SDFFCE_PN0P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C) begin\n        if (E == 1) begin\n            if (R == 0)\n                Q <= 0;\n            else\n                Q <= D;\n        end\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFCE_PN1N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:3028",
      "desc": "A positive edge D-type flip-flop with negative polarity synchronous set and negative\npolarity clock enable (with clock enable having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - / 0 0 | 1\n                   d / - 0 | d\n                   - - - - | q",
      "code": "module \\$_SDFFCE_PN1N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C) begin\n        if (E == 0) begin\n            if (R == 0)\n                Q <= 1;\n            else\n                Q <= D;\n        end\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFCE_PN1P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:3054",
      "desc": "A positive edge D-type flip-flop with negative polarity synchronous set and positive\npolarity clock enable (with clock enable having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - / 0 1 | 1\n                   d / - 1 | d\n                   - - - - | q",
      "code": "module \\$_SDFFCE_PN1P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C) begin\n        if (E == 1) begin\n            if (R == 0)\n                Q <= 1;\n            else\n                Q <= D;\n        end\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFCE_PP0N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:3080",
      "desc": "A positive edge D-type flip-flop with positive polarity synchronous reset and negative\npolarity clock enable (with clock enable having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - / 1 0 | 0\n                   d / - 0 | d\n                   - - - - | q",
      "code": "module \\$_SDFFCE_PP0N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C) begin\n        if (E == 0) begin\n            if (R == 1)\n                Q <= 0;\n            else\n                Q <= D;\n        end\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFCE_PP0P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:3106",
      "desc": "A positive edge D-type flip-flop with positive polarity synchronous reset and positive\npolarity clock enable (with clock enable having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - / 1 1 | 0\n                   d / - 1 | d\n                   - - - - | q",
      "code": "module \\$_SDFFCE_PP0P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C) begin\n        if (E == 1) begin\n            if (R == 1)\n                Q <= 0;\n            else\n                Q <= D;\n        end\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFCE_PP1N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:3132",
      "desc": "A positive edge D-type flip-flop with positive polarity synchronous set and negative\npolarity clock enable (with clock enable having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - / 1 0 | 1\n                   d / - 0 | d\n                   - - - - | q",
      "code": "module \\$_SDFFCE_PP1N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C) begin\n        if (E == 0) begin\n            if (R == 1)\n                Q <= 1;\n            else\n                Q <= D;\n        end\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFCE_PP1P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:3158",
      "desc": "A positive edge D-type flip-flop with positive polarity synchronous set and positive\npolarity clock enable (with clock enable having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - / 1 1 | 1\n                   d / - 1 | d\n                   - - - - | q",
      "code": "module \\$_SDFFCE_PP1P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C) begin\n        if (E == 1) begin\n            if (R == 1)\n                Q <= 1;\n            else\n                Q <= D;\n        end\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFE_NN0N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2384",
      "desc": "A negative edge D-type flip-flop with negative polarity synchronous reset and negative\npolarity clock enable (with reset having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - \\ 0 - | 0\n                   d \\ - 0 | d\n                   - - - - | q",
      "code": "module \\$_SDFFE_NN0N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C) begin\n        if (R == 0)\n            Q <= 0;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFE_NN0P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2408",
      "desc": "A negative edge D-type flip-flop with negative polarity synchronous reset and positive\npolarity clock enable (with reset having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - \\ 0 - | 0\n                   d \\ - 1 | d\n                   - - - - | q",
      "code": "module \\$_SDFFE_NN0P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C) begin\n        if (R == 0)\n            Q <= 0;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFE_NN1N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2432",
      "desc": "A negative edge D-type flip-flop with negative polarity synchronous set and negative\npolarity clock enable (with set having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - \\ 0 - | 1\n                   d \\ - 0 | d\n                   - - - - | q",
      "code": "module \\$_SDFFE_NN1N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C) begin\n        if (R == 0)\n            Q <= 1;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFE_NN1P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2456",
      "desc": "A negative edge D-type flip-flop with negative polarity synchronous set and positive\npolarity clock enable (with set having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - \\ 0 - | 1\n                   d \\ - 1 | d\n                   - - - - | q",
      "code": "module \\$_SDFFE_NN1P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C) begin\n        if (R == 0)\n            Q <= 1;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFE_NP0N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2480",
      "desc": "A negative edge D-type flip-flop with positive polarity synchronous reset and negative\npolarity clock enable (with reset having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - \\ 1 - | 0\n                   d \\ - 0 | d\n                   - - - - | q",
      "code": "module \\$_SDFFE_NP0N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C) begin\n        if (R == 1)\n            Q <= 0;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFE_NP0P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2504",
      "desc": "A negative edge D-type flip-flop with positive polarity synchronous reset and positive\npolarity clock enable (with reset having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - \\ 1 - | 0\n                   d \\ - 1 | d\n                   - - - - | q",
      "code": "module \\$_SDFFE_NP0P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C) begin\n        if (R == 1)\n            Q <= 0;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFE_NP1N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2528",
      "desc": "A negative edge D-type flip-flop with positive polarity synchronous set and negative\npolarity clock enable (with set having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - \\ 1 - | 1\n                   d \\ - 0 | d\n                   - - - - | q",
      "code": "module \\$_SDFFE_NP1N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C) begin\n        if (R == 1)\n            Q <= 1;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFE_NP1P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2552",
      "desc": "A negative edge D-type flip-flop with positive polarity synchronous set and positive\npolarity clock enable (with set having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - \\ 1 - | 1\n                   d \\ - 1 | d\n                   - - - - | q",
      "code": "module \\$_SDFFE_NP1P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(negedge C) begin\n        if (R == 1)\n            Q <= 1;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFE_PN0N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2576",
      "desc": "A positive edge D-type flip-flop with negative polarity synchronous reset and negative\npolarity clock enable (with reset having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - / 0 - | 0\n                   d / - 0 | d\n                   - - - - | q",
      "code": "module \\$_SDFFE_PN0N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C) begin\n        if (R == 0)\n            Q <= 0;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFE_PN0P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2600",
      "desc": "A positive edge D-type flip-flop with negative polarity synchronous reset and positive\npolarity clock enable (with reset having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - / 0 - | 0\n                   d / - 1 | d\n                   - - - - | q",
      "code": "module \\$_SDFFE_PN0P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C) begin\n        if (R == 0)\n            Q <= 0;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFE_PN1N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2624",
      "desc": "A positive edge D-type flip-flop with negative polarity synchronous set and negative\npolarity clock enable (with set having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - / 0 - | 1\n                   d / - 0 | d\n                   - - - - | q",
      "code": "module \\$_SDFFE_PN1N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C) begin\n        if (R == 0)\n            Q <= 1;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFE_PN1P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2648",
      "desc": "A positive edge D-type flip-flop with negative polarity synchronous set and positive\npolarity clock enable (with set having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - / 0 - | 1\n                   d / - 1 | d\n                   - - - - | q",
      "code": "module \\$_SDFFE_PN1P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C) begin\n        if (R == 0)\n            Q <= 1;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFE_PP0N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2672",
      "desc": "A positive edge D-type flip-flop with positive polarity synchronous reset and negative\npolarity clock enable (with reset having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - / 1 - | 0\n                   d / - 0 | d\n                   - - - - | q",
      "code": "module \\$_SDFFE_PP0N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C) begin\n        if (R == 1)\n            Q <= 0;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFE_PP0P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2696",
      "desc": "A positive edge D-type flip-flop with positive polarity synchronous reset and positive\npolarity clock enable (with reset having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - / 1 - | 0\n                   d / - 1 | d\n                   - - - - | q",
      "code": "module \\$_SDFFE_PP0P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C) begin\n        if (R == 1)\n            Q <= 0;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFE_PP1N_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2720",
      "desc": "A positive edge D-type flip-flop with positive polarity synchronous set and negative\npolarity clock enable (with set having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - / 1 - | 1\n                   d / - 0 | d\n                   - - - - | q",
      "code": "module \\$_SDFFE_PP1N_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C) begin\n        if (R == 1)\n            Q <= 1;\n        else if (E == 0)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFFE_PP1P_": {
      "title": "",
      "ports": "(D, C, R, E, Q)",
      "source": "simcells.v:2744",
      "desc": "A positive edge D-type flip-flop with positive polarity synchronous set and positive\npolarity clock enable (with set having priority).\n::\n\n   Truth table:    D C R E | Q\n                  ---------+---\n                   - / 1 - | 1\n                   d / - 1 | d\n                   - - - - | q",
      "code": "module \\$_SDFFE_PP1P_ (D, C, R, E, Q);\n    input D, C, R, E;\n    output reg Q;\n    always @(posedge C) begin\n        if (R == 1)\n            Q <= 1;\n        else if (E == 1)\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\E", "\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFF_NN0_": {
      "title": "",
      "ports": "(D, C, R, Q)",
      "source": "simcells.v:2199",
      "desc": "A negative edge D-type flip-flop with negative polarity synchronous reset.\n::\n\n   Truth table:    D C R | Q\n                  -------+---\n                   - \\ 0 | 0\n                   d \\ - | d\n                   - - - | q",
      "code": "module \\$_SDFF_NN0_ (D, C, R, Q);\n    input D, C, R;\n    output reg Q;\n    always @(negedge C) begin\n        if (R == 0)\n            Q <= 0;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFF_NN1_": {
      "title": "",
      "ports": "(D, C, R, Q)",
      "source": "simcells.v:2222",
      "desc": "A negative edge D-type flip-flop with negative polarity synchronous set.\n::\n\n   Truth table:    D C R | Q\n                  -------+---\n                   - \\ 0 | 1\n                   d \\ - | d\n                   - - - | q",
      "code": "module \\$_SDFF_NN1_ (D, C, R, Q);\n    input D, C, R;\n    output reg Q;\n    always @(negedge C) begin\n        if (R == 0)\n            Q <= 1;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFF_NP0_": {
      "title": "",
      "ports": "(D, C, R, Q)",
      "source": "simcells.v:2245",
      "desc": "A negative edge D-type flip-flop with positive polarity synchronous reset.\n::\n\n   Truth table:    D C R | Q\n                  -------+---\n                   - \\ 1 | 0\n                   d \\ - | d\n                   - - - | q",
      "code": "module \\$_SDFF_NP0_ (D, C, R, Q);\n    input D, C, R;\n    output reg Q;\n    always @(negedge C) begin\n        if (R == 1)\n            Q <= 0;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFF_NP1_": {
      "title": "",
      "ports": "(D, C, R, Q)",
      "source": "simcells.v:2268",
      "desc": "A negative edge D-type flip-flop with positive polarity synchronous set.\n::\n\n   Truth table:    D C R | Q\n                  -------+---\n                   - \\ 1 | 1\n                   d \\ - | d\n                   - - - | q",
      "code": "module \\$_SDFF_NP1_ (D, C, R, Q);\n    input D, C, R;\n    output reg Q;\n    always @(negedge C) begin\n        if (R == 1)\n            Q <= 1;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFF_PN0_": {
      "title": "",
      "ports": "(D, C, R, Q)",
      "source": "simcells.v:2291",
      "desc": "A positive edge D-type flip-flop with negative polarity synchronous reset.\n::\n\n   Truth table:    D C R | Q\n                  -------+---\n                   - / 0 | 0\n                   d / - | d\n                   - - - | q",
      "code": "module \\$_SDFF_PN0_ (D, C, R, Q);\n    input D, C, R;\n    output reg Q;\n    always @(posedge C) begin\n        if (R == 0)\n            Q <= 0;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFF_PN1_": {
      "title": "",
      "ports": "(D, C, R, Q)",
      "source": "simcells.v:2314",
      "desc": "A positive edge D-type flip-flop with negative polarity synchronous set.\n::\n\n   Truth table:    D C R | Q\n                  -------+---\n                   - / 0 | 1\n                   d / - | d\n                   - - - | q",
      "code": "module \\$_SDFF_PN1_ (D, C, R, Q);\n    input D, C, R;\n    output reg Q;\n    always @(posedge C) begin\n        if (R == 0)\n            Q <= 1;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFF_PP0_": {
      "title": "",
      "ports": "(D, C, R, Q)",
      "source": "simcells.v:2337",
      "desc": "A positive edge D-type flip-flop with positive polarity synchronous reset.\n::\n\n   Truth table:    D C R | Q\n                  -------+---\n                   - / 1 | 0\n                   d / - | d\n                   - - - | q",
      "code": "module \\$_SDFF_PP0_ (D, C, R, Q);\n    input D, C, R;\n    output reg Q;\n    always @(posedge C) begin\n        if (R == 1)\n            Q <= 0;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SDFF_PP1_": {
      "title": "",
      "ports": "(D, C, R, Q)",
      "source": "simcells.v:2360",
      "desc": "A positive edge D-type flip-flop with positive polarity synchronous set.\n::\n\n   Truth table:    D C R | Q\n                  -------+---\n                   - / 1 | 1\n                   d / - | d\n                   - - - | q",
      "code": "module \\$_SDFF_PP1_ (D, C, R, Q);\n    input D, C, R;\n    output reg Q;\n    always @(posedge C) begin\n        if (R == 1)\n            Q <= 1;\n        else\n            Q <= D;\n    end\nendmodule",
      "inputs": ["\\D", "\\R", "\\C"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SR_NN_": {
      "title": "",
      "ports": "(S, R, Q)",
      "source": "simcells.v:476",
      "desc": "A set-reset latch with negative polarity SET and negative polarity RESET.\n::\n\n   Truth table:    S R | Q\n                  -----+---\n                   - 0 | 0\n                   0 - | 1\n                   - - | q",
      "code": "module \\$_SR_NN_ (S, R, Q);\n    input S, R;\n    output reg Q;\n    always @* begin\n        if (R == 0)\n            Q <= 0;\n        else if (S == 0)\n            Q <= 1;\n    end\nendmodule",
      "inputs": ["\\R", "\\S"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SR_NP_": {
      "title": "",
      "ports": "(S, R, Q)",
      "source": "simcells.v:499",
      "desc": "A set-reset latch with negative polarity SET and positive polarity RESET.\n::\n\n   Truth table:    S R | Q\n                  -----+---\n                   - 1 | 0\n                   0 - | 1\n                   - - | q",
      "code": "module \\$_SR_NP_ (S, R, Q);\n    input S, R;\n    output reg Q;\n    always @* begin\n        if (R == 1)\n            Q <= 0;\n        else if (S == 0)\n            Q <= 1;\n    end\nendmodule",
      "inputs": ["\\R", "\\S"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SR_PN_": {
      "title": "",
      "ports": "(S, R, Q)",
      "source": "simcells.v:522",
      "desc": "A set-reset latch with positive polarity SET and negative polarity RESET.\n::\n\n   Truth table:    S R | Q\n                  -----+---\n                   - 0 | 0\n                   1 - | 1\n                   - - | q",
      "code": "module \\$_SR_PN_ (S, R, Q);\n    input S, R;\n    output reg Q;\n    always @* begin\n        if (R == 0)\n            Q <= 0;\n        else if (S == 1)\n            Q <= 1;\n    end\nendmodule",
      "inputs": ["\\R", "\\S"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_SR_PP_": {
      "title": "",
      "ports": "(S, R, Q)",
      "source": "simcells.v:545",
      "desc": "A set-reset latch with positive polarity SET and positive polarity RESET.\n::\n\n   Truth table:    S R | Q\n                  -----+---\n                   - 1 | 0\n                   1 - | 1\n                   - - | q",
      "code": "module \\$_SR_PP_ (S, R, Q);\n    input S, R;\n    output reg Q;\n    always @* begin\n        if (R == 1)\n            Q <= 0;\n        else if (S == 1)\n            Q <= 1;\n    end\nendmodule",
      "inputs": ["\\R", "\\S"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$_TBUF_": {
      "title": "",
      "ports": "(A, E, Y)",
      "source": "simcells.v:453",
      "desc": "A tri-state buffer.\n::\n\n   Truth table:    A E | Y\n                  -----+---\n                   a 1 | a\n                   - 0 | z",
      "code": "module \\$_TBUF_ (A, E, Y);\n    input A, E;\n    output Y;\n    assign Y = E ? A : 1'bz;\nendmodule",
      "inputs": ["\\E", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$_XNOR_": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simcells.v:170",
      "desc": "A 2-input XNOR gate.\n::\n\n   Truth table:    A B | Y\n                  -----+---\n                   0 0 | 1\n                   0 1 | 0\n                   1 0 | 0\n                   1 1 | 1",
      "code": "module \\$_XNOR_ (A, B, Y);\n    input A, B;\n    output Y;\n    assign Y = ~(A ^ B);\nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$_XOR_": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simcells.v:151",
      "desc": "A 2-input XOR gate.\n::\n\n   Truth table:    A B | Y\n                  -----+---\n                   0 0 | 0\n                   0 1 | 1\n                   1 0 | 1\n                   1 1 | 0",
      "code": "module \\$_XOR_ (A, B, Y);\n    input A, B;\n    output Y;\n    assign Y = A ^ B;\nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$add": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:859",
      "desc": "",
      "code": "module \\$add (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) + $signed(B);\n        end else begin:BLOCK2\n            assign Y = A + B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$adff": {
      "title": "",
      "ports": "(CLK, ARST, D, Q)",
      "source": "simlib.v:2112",
      "desc": "",
      "code": "module \\$adff (CLK, ARST, D, Q);\n    \n    parameter WIDTH = 0;\n    parameter CLK_POLARITY = 1'b1;\n    parameter ARST_POLARITY = 1'b1;\n    parameter ARST_VALUE = 0;\n    \n    input CLK, ARST;\n    input [WIDTH-1:0] D;\n    output reg [WIDTH-1:0] Q;\n    wire pos_clk = CLK == CLK_POLARITY;\n    wire pos_arst = ARST == ARST_POLARITY;\n    \n    always @(posedge pos_clk, posedge pos_arst) begin\n        if (pos_arst)\n            Q <= ARST_VALUE;\n        else\n            Q <= D;\n    end\n    \nendmodule",
      "inputs": ["\\D", "\\ARST", "\\CLK"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$adffe": {
      "title": "",
      "ports": "(CLK, ARST, EN, D, Q)",
      "source": "simlib.v:2187",
      "desc": "",
      "code": "module \\$adffe (CLK, ARST, EN, D, Q);\n    \n    parameter WIDTH = 0;\n    parameter CLK_POLARITY = 1'b1;\n    parameter EN_POLARITY = 1'b1;\n    parameter ARST_POLARITY = 1'b1;\n    parameter ARST_VALUE = 0;\n    \n    input CLK, ARST, EN;\n    input [WIDTH-1:0] D;\n    output reg [WIDTH-1:0] Q;\n    wire pos_clk = CLK == CLK_POLARITY;\n    wire pos_arst = ARST == ARST_POLARITY;\n    \n    always @(posedge pos_clk, posedge pos_arst) begin\n        if (pos_arst)\n            Q <= ARST_VALUE;\n        else if (EN == EN_POLARITY)\n            Q <= D;\n    end\n    \nendmodule",
      "inputs": ["\\EN", "\\D", "\\ARST", "\\CLK"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$adlatch": {
      "title": "",
      "ports": "(EN, ARST, D, Q)",
      "source": "simlib.v:2312",
      "desc": "",
      "code": "module \\$adlatch (EN, ARST, D, Q);\n    \n    parameter WIDTH = 0;\n    parameter EN_POLARITY = 1'b1;\n    parameter ARST_POLARITY = 1'b1;\n    parameter ARST_VALUE = 0;\n    \n    input EN, ARST;\n    input [WIDTH-1:0] D;\n    output reg [WIDTH-1:0] Q;\n    \n    always @* begin\n        if (ARST == ARST_POLARITY)\n            Q = ARST_VALUE;\n        else if (EN == EN_POLARITY)\n            Q = D;\n    end\n    \nendmodule",
      "inputs": ["\\ARST", "\\D", "\\EN"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$aldff": {
      "title": "",
      "ports": "(CLK, ALOAD, AD, D, Q)",
      "source": "simlib.v:2137",
      "desc": "",
      "code": "module \\$aldff (CLK, ALOAD, AD, D, Q);\n    \n    parameter WIDTH = 0;\n    parameter CLK_POLARITY = 1'b1;\n    parameter ALOAD_POLARITY = 1'b1;\n    \n    input CLK, ALOAD;\n    input [WIDTH-1:0] AD;\n    input [WIDTH-1:0] D;\n    output reg [WIDTH-1:0] Q;\n    wire pos_clk = CLK == CLK_POLARITY;\n    wire pos_aload = ALOAD == ALOAD_POLARITY;\n    \n    always @(posedge pos_clk, posedge pos_aload) begin\n        if (pos_aload)\n            Q <= AD;\n        else\n            Q <= D;\n    end\n    \nendmodule",
      "inputs": ["\\D", "\\AD", "\\ALOAD", "\\CLK"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$aldffe": {
      "title": "",
      "ports": "(CLK, ALOAD, AD, EN, D, Q)",
      "source": "simlib.v:2213",
      "desc": "",
      "code": "module \\$aldffe (CLK, ALOAD, AD, EN, D, Q);\n    \n    parameter WIDTH = 0;\n    parameter CLK_POLARITY = 1'b1;\n    parameter EN_POLARITY = 1'b1;\n    parameter ALOAD_POLARITY = 1'b1;\n    \n    input CLK, ALOAD, EN;\n    input [WIDTH-1:0] D;\n    input [WIDTH-1:0] AD;\n    output reg [WIDTH-1:0] Q;\n    wire pos_clk = CLK == CLK_POLARITY;\n    wire pos_aload = ALOAD == ALOAD_POLARITY;\n    \n    always @(posedge pos_clk, posedge pos_aload) begin\n        if (pos_aload)\n            Q <= AD;\n        else if (EN == EN_POLARITY)\n            Q <= D;\n    end\n    \nendmodule",
      "inputs": ["\\EN", "\\D", "\\AD", "\\ALOAD", "\\CLK"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$allconst": {
      "title": "",
      "ports": "(Y)",
      "source": "simlib.v:1864",
      "desc": "",
      "code": "module \\$allconst (Y);\n    \n    parameter WIDTH = 0;\n    \n    output [WIDTH-1:0] Y;\n    \n    assign Y = 'bx;\n    \nendmodule",
      "inputs": [],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$allseq": {
      "title": "",
      "ports": "(Y)",
      "source": "simlib.v:1877",
      "desc": "",
      "code": "module \\$allseq (Y);\n    \n    parameter WIDTH = 0;\n    \n    output [WIDTH-1:0] Y;\n    \n    assign Y = 'bx;\n    \nendmodule",
      "inputs": [],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$alu": {
      "title": "Arithmetic logic unit",
      "ports": "(A, B, CI, BI, X, Y, CO)",
      "source": "simlib.v:605",
      "desc": "A building block supporting both binary addition/subtraction operations, and\nindirectly, comparison operations.\nTypically created by the `alumacc` pass, which transforms:\n`$add`, `$sub`, `$lt`, `$le`, `$ge`, `$gt`, `$eq`, `$eqx`, `$ne`, `$nex`\ncells into this `$alu` cell.",
      "code": "module \\$alu (A, B, CI, BI, X, Y, CO);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 1;\n    parameter B_WIDTH = 1;\n    parameter Y_WIDTH = 1;\n    \n    input [A_WIDTH-1:0] A;      // Input operand\n    input [B_WIDTH-1:0] B;      // Input operand\n    output [Y_WIDTH-1:0] X;     // A xor B (sign-extended, optional B inversion,\n                                //          used in combination with\n                                //          reduction-AND for $eq/$ne ops)\n    output [Y_WIDTH-1:0] Y;     // Sum\n    \n    input CI;                   // Carry-in (set for $sub)\n    input BI;                   // Invert-B (set for $sub)\n    output [Y_WIDTH-1:0] CO;    // Carry-out\n    \n    wire [Y_WIDTH-1:0] AA, BB;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            assign AA = $signed(A), BB = BI ? ~$signed(B) : $signed(B);\n        end else begin:BLOCK2\n            assign AA = $unsigned(A), BB = BI ? ~$unsigned(B) : $unsigned(B);\n        end\n    endgenerate\n    \n    // this is 'x' if Y and CO should be all 'x', and '0' otherwise\n    wire y_co_undef = ^{A, A, B, B, CI, CI, BI, BI};\n    \n    assign X = AA ^ BB;\n    // Full adder\n    assign Y = (AA + BB + CI) ^ {Y_WIDTH{y_co_undef}};\n    \n    function get_carry;\n        input a, b, c;\n        get_carry = (a&b) | (a&c) | (b&c);\n    endfunction\n    \n    genvar i;\n    generate\n        assign CO[0] = get_carry(AA[0], BB[0], CI) ^ y_co_undef;\n        for (i = 1; i < Y_WIDTH; i = i+1) begin:BLOCK3\n            assign CO[i] = get_carry(AA[i], BB[i], CO[i-1]) ^ y_co_undef;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\BI", "\\CI", "\\B", "\\A"],
      "outputs": ["\\CO", "\\Y", "\\X"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$and": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:126",
      "desc": "A bit-wise AND. This corresponds to the Verilog '&' operator.",
      "code": "module \\$and (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) & $signed(B);\n        end else begin:BLOCK2\n            assign Y = A & B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$anyconst": {
      "title": "",
      "ports": "(Y)",
      "source": "simlib.v:1817",
      "desc": "",
      "code": "module \\$anyconst (Y);\n    \n    parameter WIDTH = 0;\n    \n    output [WIDTH-1:0] Y;\n    \n    assign Y = 'bx;\n    \nendmodule",
      "inputs": [],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$anyinit": {
      "title": "",
      "ports": "(D, Q)",
      "source": "simlib.v:1846",
      "desc": "",
      "code": "module \\$anyinit (D, Q);\n    \n    parameter WIDTH = 0;\n    \n    input [WIDTH-1:0] D;\n    output reg [WIDTH-1:0] Q;\n    \n    initial Q <= 'bx;\n    \n    always @(`SIMLIB_GLOBAL_CLOCK) begin\n        Q <= D;\n    end\n    \nendmodule",
      "inputs": ["\\D"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$anyseq": {
      "title": "",
      "ports": "(Y)",
      "source": "simlib.v:1830",
      "desc": "",
      "code": "module \\$anyseq (Y);\n    \n    parameter WIDTH = 0;\n    \n    output [WIDTH-1:0] Y;\n    \n    assign Y = 'bx;\n    \nendmodule",
      "inputs": [],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$assert": {
      "title": "",
      "ports": "(A, EN)",
      "source": "simlib.v:1736",
      "desc": "",
      "code": "module \\$assert (A, EN);\n    \n    input A, EN;\n    \n    `ifndef SIMLIB_NOCHECKS\n    always @* begin\n        if (A !== 1'b1 && EN === 1'b1) begin\n            $display(\"Assertion %m failed!\");\n            $stop;\n        end\n    end\n    `endif\n    \nendmodule",
      "inputs": ["\\EN", "\\A"],
      "outputs": [],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$assume": {
      "title": "",
      "ports": "(A, EN)",
      "source": "simlib.v:1754",
      "desc": "",
      "code": "module \\$assume (A, EN);\n    \n    input A, EN;\n    \n    `ifndef SIMLIB_NOCHECKS\n    always @* begin\n        if (A !== 1'b1 && EN === 1'b1) begin\n            $display(\"Assumption %m failed!\");\n            $stop;\n        end\n    end\n    `endif\n    \nendmodule",
      "inputs": ["\\EN", "\\A"],
      "outputs": [],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$bmux": {
      "title": "",
      "ports": "(A, S, Y)",
      "source": "simlib.v:1376",
      "desc": "",
      "code": "module \\$bmux (A, S, Y);\n    \n    parameter WIDTH = 0;\n    parameter S_WIDTH = 0;\n    \n    input [(WIDTH << S_WIDTH)-1:0] A;\n    input [S_WIDTH-1:0] S;\n    output [WIDTH-1:0] Y;\n    \n    wire [WIDTH-1:0] bm0_out, bm1_out;\n    \n    generate\n        if (S_WIDTH > 1) begin:muxlogic\n            \\$bmux #(.WIDTH(WIDTH), .S_WIDTH(S_WIDTH-1)) bm0 (.A(A[(WIDTH << (S_WIDTH - 1))-1:0]), .S(S[S_WIDTH-2:0]), .Y(bm0_out));\n            \\$bmux #(.WIDTH(WIDTH), .S_WIDTH(S_WIDTH-1)) bm1 (.A(A[(WIDTH << S_WIDTH)-1:WIDTH << (S_WIDTH - 1)]), .S(S[S_WIDTH-2:0]), .Y(bm1_out));\n            assign Y = S[S_WIDTH-1] ? bm1_out : bm0_out;\n        end else if (S_WIDTH == 1) begin:simple\n            assign Y = S ? A[2*WIDTH-1:WIDTH] : A[WIDTH-1:0];\n        end else begin:passthru\n            assign Y = A;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\S", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$bweqx": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:1698",
      "desc": "",
      "code": "module \\$bweqx (A, B, Y);\n    \n    parameter WIDTH = 0;\n    \n    input [WIDTH-1:0] A, B;\n    output [WIDTH-1:0] Y;\n    \n    genvar i;\n    generate\n        for (i = 0; i < WIDTH; i = i + 1) begin:slices\n            assign Y[i] = A[i] === B[i];\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$bwmux": {
      "title": "",
      "ports": "(A, B, S, Y)",
      "source": "simlib.v:1716",
      "desc": "",
      "code": "module \\$bwmux (A, B, S, Y);\n    \n    parameter WIDTH = 0;\n    \n    input [WIDTH-1:0] A, B;\n    input [WIDTH-1:0] S;\n    output [WIDTH-1:0] Y;\n    \n    genvar i;\n    generate\n        for (i = 0; i < WIDTH; i = i + 1) begin:slices\n            assign Y[i] = S[i] ? B[i] : A[i];\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\S", "\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$check": {
      "title": "",
      "ports": "(A, EN, TRG, ARGS)",
      "source": "simlib.v:1931",
      "desc": "",
      "code": "module \\$check (A, EN, TRG, ARGS);\n    \n    parameter FLAVOR = \"\";\n    parameter PRIORITY = 0;\n    \n    parameter FORMAT = \"\";\n    parameter ARGS_WIDTH = 0;\n    \n    parameter TRG_ENABLE = 1;\n    parameter TRG_WIDTH = 0;\n    parameter TRG_POLARITY = 0;\n    \n    input A;\n    input EN;\n    input [TRG_WIDTH-1:0] TRG;\n    input [ARGS_WIDTH-1:0] ARGS;\n    \nendmodule",
      "inputs": ["\\TRG", "\\ARGS", "\\EN", "\\A"],
      "outputs": [],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$concat": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:1345",
      "desc": "",
      "code": "module \\$concat (A, B, Y);\n    \n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [A_WIDTH+B_WIDTH-1:0] Y;\n    \n    assign Y = {B, A};\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$cover": {
      "title": "",
      "ports": "(A, EN)",
      "source": "simlib.v:1790",
      "desc": "",
      "code": "module \\$cover (A, EN);\n    \n    input A, EN;\n    \nendmodule",
      "inputs": ["\\EN", "\\A"],
      "outputs": [],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$demux": {
      "title": "",
      "ports": "(A, S, Y)",
      "source": "simlib.v:1439",
      "desc": "",
      "code": "module \\$demux (A, S, Y);\n    \n    parameter WIDTH = 1;\n    parameter S_WIDTH = 1;\n    \n    input [WIDTH-1:0] A;\n    input [S_WIDTH-1:0] S;\n    output [(WIDTH << S_WIDTH)-1:0] Y;\n    \n    genvar i;\n    generate\n        for (i = 0; i < (1 << S_WIDTH); i = i + 1) begin:slices\n            assign Y[i*WIDTH+:WIDTH] = (S == i) ? A : 0;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\S", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$dff": {
      "title": "",
      "ports": "(CLK, D, Q)",
      "source": "simlib.v:2004",
      "desc": "",
      "code": "module \\$dff (CLK, D, Q);\n    \n    parameter WIDTH = 0;\n    parameter CLK_POLARITY = 1'b1;\n    \n    input CLK;\n    input [WIDTH-1:0] D;\n    output reg [WIDTH-1:0] Q;\n    wire pos_clk = CLK == CLK_POLARITY;\n    \n    always @(posedge pos_clk) begin\n        Q <= D;\n    end\n    \nendmodule",
      "inputs": ["\\D", "\\CLK"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$dffe": {
      "title": "",
      "ports": "(CLK, EN, D, Q)",
      "source": "simlib.v:2023",
      "desc": "",
      "code": "module \\$dffe (CLK, EN, D, Q);\n    \n    parameter WIDTH = 0;\n    parameter CLK_POLARITY = 1'b1;\n    parameter EN_POLARITY = 1'b1;\n    \n    input CLK, EN;\n    input [WIDTH-1:0] D;\n    output reg [WIDTH-1:0] Q;\n    wire pos_clk = CLK == CLK_POLARITY;\n    \n    always @(posedge pos_clk) begin\n        if (EN == EN_POLARITY) Q <= D;\n    end\n    \nendmodule",
      "inputs": ["\\D", "\\EN", "\\CLK"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$dffsr": {
      "title": "",
      "ports": "(CLK, SET, CLR, D, Q)",
      "source": "simlib.v:2044",
      "desc": "",
      "code": "module \\$dffsr (CLK, SET, CLR, D, Q);\n    \n    parameter WIDTH = 0;\n    parameter CLK_POLARITY = 1'b1;\n    parameter SET_POLARITY = 1'b1;\n    parameter CLR_POLARITY = 1'b1;\n    \n    input CLK;\n    input [WIDTH-1:0] SET, CLR, D;\n    output reg [WIDTH-1:0] Q;\n    \n    wire pos_clk = CLK == CLK_POLARITY;\n    wire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;\n    wire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;\n    \n    genvar i;\n    generate\n        for (i = 0; i < WIDTH; i = i+1) begin:bitslices\n            always @(posedge pos_set[i], posedge pos_clr[i], posedge pos_clk)\n                if (pos_clr[i])\n                    Q[i] <= 0;\n                else if (pos_set[i])\n                    Q[i] <= 1;\n                else\n                    Q[i] <= D[i];\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\D", "\\CLR", "\\SET", "\\CLK"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$dffsre": {
      "title": "",
      "ports": "(CLK, SET, CLR, EN, D, Q)",
      "source": "simlib.v:2077",
      "desc": "",
      "code": "module \\$dffsre (CLK, SET, CLR, EN, D, Q);\n    \n    parameter WIDTH = 0;\n    parameter CLK_POLARITY = 1'b1;\n    parameter SET_POLARITY = 1'b1;\n    parameter CLR_POLARITY = 1'b1;\n    parameter EN_POLARITY = 1'b1;\n    \n    input CLK, EN;\n    input [WIDTH-1:0] SET, CLR, D;\n    output reg [WIDTH-1:0] Q;\n    \n    wire pos_clk = CLK == CLK_POLARITY;\n    wire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;\n    wire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;\n    \n    genvar i;\n    generate\n        for (i = 0; i < WIDTH; i = i+1) begin:bitslices\n            always @(posedge pos_set[i], posedge pos_clr[i], posedge pos_clk)\n                if (pos_clr[i])\n                    Q[i] <= 0;\n                else if (pos_set[i])\n                    Q[i] <= 1;\n                else if (EN == EN_POLARITY)\n                    Q[i] <= D[i];\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\EN", "\\D", "\\CLR", "\\SET", "\\CLK"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$div": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:1091",
      "desc": "Division with truncated result (rounded towards 0).",
      "code": "module \\$div (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) / $signed(B);\n        end else begin:BLOCK2\n            assign Y = A / B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$divfloor": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:1155",
      "desc": "Division with floored result (rounded towards negative infinity).",
      "code": "module \\$divfloor (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            localparam WIDTH =\n                    A_WIDTH >= B_WIDTH && A_WIDTH >= Y_WIDTH ? A_WIDTH :\n                    B_WIDTH >= A_WIDTH && B_WIDTH >= Y_WIDTH ? B_WIDTH : Y_WIDTH;\n            wire [WIDTH:0] A_buf, B_buf, N_buf;\n            assign A_buf = $signed(A);\n            assign B_buf = $signed(B);\n            assign N_buf = (A[A_WIDTH-1] == B[B_WIDTH-1]) || A == 0 ? A_buf : $signed(A_buf - (B[B_WIDTH-1] ? B_buf+1 : B_buf-1));\n            assign Y = $signed(N_buf) / $signed(B_buf);\n        end else begin:BLOCK2\n            assign Y = A / B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$dlatch": {
      "title": "",
      "ports": "(EN, D, Q)",
      "source": "simlib.v:2293",
      "desc": "",
      "code": "module \\$dlatch (EN, D, Q);\n    \n    parameter WIDTH = 0;\n    parameter EN_POLARITY = 1'b1;\n    \n    input EN;\n    input [WIDTH-1:0] D;\n    output reg [WIDTH-1:0] Q;\n    \n    always @* begin\n        if (EN == EN_POLARITY)\n            Q = D;\n    end\n    \nendmodule",
      "inputs": ["\\D", "\\EN"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$dlatchsr": {
      "title": "",
      "ports": "(EN, SET, CLR, D, Q)",
      "source": "simlib.v:2336",
      "desc": "",
      "code": "module \\$dlatchsr (EN, SET, CLR, D, Q);\n    \n    parameter WIDTH = 0;\n    parameter EN_POLARITY = 1'b1;\n    parameter SET_POLARITY = 1'b1;\n    parameter CLR_POLARITY = 1'b1;\n    \n    input EN;\n    input [WIDTH-1:0] SET, CLR, D;\n    output reg [WIDTH-1:0] Q;\n    \n    wire pos_en = EN == EN_POLARITY;\n    wire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;\n    wire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;\n    \n    genvar i;\n    generate\n        for (i = 0; i < WIDTH; i = i+1) begin:bitslices\n            always @*\n                if (pos_clr[i])\n                    Q[i] = 0;\n                else if (pos_set[i])\n                    Q[i] = 1;\n                else if (pos_en)\n                    Q[i] = D[i];\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\D", "\\CLR", "\\SET", "\\EN"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$eq": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:709",
      "desc": "",
      "code": "module \\$eq (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) == $signed(B);\n        end else begin:BLOCK2\n            assign Y = A == B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$equiv": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:1890",
      "desc": "",
      "code": "module \\$equiv (A, B, Y);\n    \n    input A, B;\n    output Y;\n    \n    assign Y = (A !== 1'bx && A !== B) ? 1'bx : A;\n    \n    `ifndef SIMLIB_NOCHECKS\n    always @* begin\n        if (A !== 1'bx && A !== B) begin\n            $display(\"Equivalence failed!\");\n            $stop;\n        end\n    end\n    `endif\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$eqx": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:759",
      "desc": "",
      "code": "module \\$eqx (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) === $signed(B);\n        end else begin:BLOCK2\n            assign Y = A === B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$fa": {
      "title": "",
      "ports": "(A, B, C, X, Y)",
      "source": "simlib.v:544",
      "desc": "",
      "code": "module \\$fa (A, B, C, X, Y);\n    \n    parameter WIDTH = 1;\n    \n    input [WIDTH-1:0] A, B, C;\n    output [WIDTH-1:0] X, Y;\n    \n    wire [WIDTH-1:0] t1, t2, t3;\n    \n    assign t1 = A ^ B, t2 = A & B, t3 = C & t1;\n    assign Y = t1 ^ C, X = (t2 | t3) ^ (Y ^ Y);\n    \nendmodule",
      "inputs": ["\\C", "\\B", "\\A"],
      "outputs": ["\\Y", "\\X"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$fair": {
      "title": "",
      "ports": "(A, EN)",
      "source": "simlib.v:1781",
      "desc": "",
      "code": "module \\$fair (A, EN);\n    \n    input A, EN;\n    \nendmodule",
      "inputs": ["\\EN", "\\A"],
      "outputs": [],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$ff": {
      "title": "",
      "ports": "(D, Q)",
      "source": "simlib.v:1987",
      "desc": "",
      "code": "module \\$ff (D, Q);\n    \n    parameter WIDTH = 0;\n    \n    input [WIDTH-1:0] D;\n    output reg [WIDTH-1:0] Q;\n    \n    always @(`SIMLIB_GLOBAL_CLOCK) begin\n        Q <= D;\n    end\n    \nendmodule",
      "inputs": ["\\D"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$fsm": {
      "title": "",
      "ports": "(CLK, ARST, CTRL_IN, CTRL_OUT)",
      "source": "simlib.v:2370",
      "desc": "",
      "code": "module \\$fsm (CLK, ARST, CTRL_IN, CTRL_OUT);\n    \n    parameter NAME = \"\";\n    \n    parameter CLK_POLARITY = 1'b1;\n    parameter ARST_POLARITY = 1'b1;\n    \n    parameter CTRL_IN_WIDTH = 1;\n    parameter CTRL_OUT_WIDTH = 1;\n    \n    parameter STATE_BITS = 1;\n    parameter STATE_NUM = 1;\n    parameter STATE_NUM_LOG2 = 1;\n    parameter STATE_RST = 0;\n    parameter STATE_TABLE = 1'b0;\n    \n    parameter TRANS_NUM = 1;\n    parameter TRANS_TABLE = 4'b0x0x;\n    \n    input CLK, ARST;\n    input [CTRL_IN_WIDTH-1:0] CTRL_IN;\n    output reg [CTRL_OUT_WIDTH-1:0] CTRL_OUT;\n    \n    wire pos_clk = CLK == CLK_POLARITY;\n    wire pos_arst = ARST == ARST_POLARITY;\n    \n    reg [STATE_BITS-1:0] state;\n    reg [STATE_BITS-1:0] state_tmp;\n    reg [STATE_BITS-1:0] next_state;\n    \n    reg [STATE_BITS-1:0] tr_state_in;\n    reg [STATE_BITS-1:0] tr_state_out;\n    reg [CTRL_IN_WIDTH-1:0] tr_ctrl_in;\n    reg [CTRL_OUT_WIDTH-1:0] tr_ctrl_out;\n    \n    integer i;\n    \n    task tr_fetch;\n        input [31:0] tr_num;\n        reg [31:0] tr_pos;\n        reg [STATE_NUM_LOG2-1:0] state_num;\n        begin\n            tr_pos = (2*STATE_NUM_LOG2+CTRL_IN_WIDTH+CTRL_OUT_WIDTH)*tr_num;\n            tr_ctrl_out = TRANS_TABLE >> tr_pos;\n            tr_pos = tr_pos + CTRL_OUT_WIDTH;\n            state_num = TRANS_TABLE >> tr_pos;\n            tr_state_out = STATE_TABLE >> (STATE_BITS*state_num);\n            tr_pos = tr_pos + STATE_NUM_LOG2;\n            tr_ctrl_in = TRANS_TABLE >> tr_pos;\n            tr_pos = tr_pos + CTRL_IN_WIDTH;\n            state_num = TRANS_TABLE >> tr_pos;\n            tr_state_in = STATE_TABLE >> (STATE_BITS*state_num);\n            tr_pos = tr_pos + STATE_NUM_LOG2;\n        end\n    endtask\n    \n    always @(posedge pos_clk, posedge pos_arst) begin\n        if (pos_arst) begin\n            state_tmp = STATE_TABLE[STATE_BITS*(STATE_RST+1)-1:STATE_BITS*STATE_RST];\n            for (i = 0; i < STATE_BITS; i = i+1)\n                if (state_tmp[i] === 1'bz)\n                    state_tmp[i] = 0;\n            state <= state_tmp;\n        end else begin\n            state_tmp = next_state;\n            for (i = 0; i < STATE_BITS; i = i+1)\n                if (state_tmp[i] === 1'bz)\n                    state_tmp[i] = 0;\n            state <= state_tmp;\n        end\n    end\n    \n    always @(state, CTRL_IN) begin\n        next_state <= STATE_TABLE[STATE_BITS*(STATE_RST+1)-1:STATE_BITS*STATE_RST];\n        CTRL_OUT <= 'bx;\n        // $display(\"---\");\n        // $display(\"Q: %b %b\", state, CTRL_IN);\n        for (i = 0; i < TRANS_NUM; i = i+1) begin\n            tr_fetch(i);\n            // $display(\"T: %b %b -> %b %b [%d]\", tr_state_in, tr_ctrl_in, tr_state_out, tr_ctrl_out, i);\n            casez ({state, CTRL_IN})\n                {tr_state_in, tr_ctrl_in}: begin\n                    // $display(\"-> %b %b <-   MATCH\", state, CTRL_IN);\n                    {next_state, CTRL_OUT} <= {tr_state_out, tr_ctrl_out};\n                end\n            endcase\n        end\n    end\n    \nendmodule",
      "inputs": ["\\CTRL_IN", "\\ARST", "\\CLK"],
      "outputs": ["\\CTRL_OUT"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$future_ff": {
      "title": "",
      "ports": "(A, Y)",
      "source": "simlib.v:2889",
      "desc": "",
      "code": "module \\$future_ff (A, Y);\n    \n    parameter WIDTH = 0;\n    \n    input [WIDTH-1:0] A;\n    output [WIDTH-1:0] Y;\n    \n    assign Y = A;\n    \nendmodule",
      "inputs": ["\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$ge": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:809",
      "desc": "",
      "code": "module \\$ge (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) >= $signed(B);\n        end else begin:BLOCK2\n            assign Y = A >= B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$get_tag": {
      "title": "",
      "ports": "(A, Y)",
      "source": "simlib.v:2848",
      "desc": "",
      "code": "module \\$get_tag (A, Y);\n    \n    parameter TAG = \"\";\n    parameter WIDTH = 0;\n    \n    input [WIDTH-1:0] A;\n    output [WIDTH-1:0] Y;\n    \n    assign Y = A;\n    \nendmodule",
      "inputs": ["\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$gt": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:834",
      "desc": "",
      "code": "module \\$gt (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) > $signed(B);\n        end else begin:BLOCK2\n            assign Y = A > B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$initstate": {
      "title": "",
      "ports": "(Y)",
      "source": "simlib.v:1799",
      "desc": "",
      "code": "module \\$initstate (Y);\n    \n    output reg Y = 1;\n    reg [3:0] cnt = 1;\n    reg trig = 0;\n    \n    initial trig <= 1;\n    \n    always @(cnt, trig) begin\n        Y <= |cnt;\n        cnt <= cnt + |cnt;\n    end\n    \nendmodule",
      "inputs": [],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$lcu": {
      "title": "",
      "ports": "(P, G, CI, CO)",
      "source": "simlib.v:572",
      "desc": "Lookahead carry unit\nA building block dedicated to fast computation of carry-bits used in binary\narithmetic operations. By replacing the ripple carry structure used in full-adder\nblocks, the more significant  bits of the sum can be expected to be computed more\nquickly.\nTypically created during `techmap` of $alu cells (see the \"_90_alu\" rule in\n+/techmap.v).",
      "code": "module \\$lcu (P, G, CI, CO);\n    \n    parameter WIDTH = 1;\n    \n    input [WIDTH-1:0] P;    // Propagate\n    input [WIDTH-1:0] G;    // Generate\n    input CI;               // Carry-in\n    \n    output reg [WIDTH-1:0] CO; // Carry-out\n    \n    integer i;\n    always @* begin\n        CO = 'bx;\n        if (^{P, G, CI} !== 1'bx) begin\n            CO[0] = G[0] || (P[0] && CI);\n            for (i = 1; i < WIDTH; i = i+1)\n                CO[i] = G[i] || (P[i] && CO[i-1]);\n        end\n    end\n    \nendmodule",
      "inputs": ["\\CI", "\\G", "\\P"],
      "outputs": ["\\CO"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$le": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:684",
      "desc": "",
      "code": "module \\$le (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) <= $signed(B);\n        end else begin:BLOCK2\n            assign Y = A <= B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$live": {
      "title": "",
      "ports": "(A, EN)",
      "source": "simlib.v:1772",
      "desc": "",
      "code": "module \\$live (A, EN);\n    \n    input A, EN;\n    \nendmodule",
      "inputs": ["\\EN", "\\A"],
      "outputs": [],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$logic_and": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:1281",
      "desc": "",
      "code": "module \\$logic_and (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) && $signed(B);\n        end else begin:BLOCK2\n            assign Y = A && B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$logic_not": {
      "title": "",
      "ports": "(A, Y)",
      "source": "simlib.v:1259",
      "desc": "",
      "code": "module \\$logic_not (A, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED) begin:BLOCK1\n            assign Y = !$signed(A);\n        end else begin:BLOCK2\n            assign Y = !A;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$logic_or": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:1306",
      "desc": "",
      "code": "module \\$logic_or (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) || $signed(B);\n        end else begin:BLOCK2\n            assign Y = A || B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$lt": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:659",
      "desc": "",
      "code": "module \\$lt (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) < $signed(B);\n        end else begin:BLOCK2\n            assign Y = A < B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$lut": {
      "title": "",
      "ports": "(A, Y)",
      "source": "simlib.v:1461",
      "desc": "",
      "code": "module \\$lut (A, Y);\n    \n    parameter WIDTH = 0;\n    parameter LUT = 0;\n    \n    input [WIDTH-1:0] A;\n    output Y;\n    \n    \\$bmux #(.WIDTH(1), .S_WIDTH(WIDTH)) mux(.A(LUT[(1<<WIDTH)-1:0]), .S(A), .Y(Y));\n    \nendmodule",
      "inputs": ["\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$macc": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:945",
      "desc": "Multiply and accumulate.\nA building block for summing any number of negated and unnegated signals\nand arithmetic products of pairs of signals. Cell port A concatenates pairs\nof signals to be multiplied together. When the second signal in a pair is zero\nlength, a constant 1 is used instead as the second factor. Cell port B\nconcatenates 1-bit-wide signals to also be summed, such as \"carry in\" in adders.\nTypically created by the `alumacc` pass, which transforms $add and $mul\ninto $macc cells.",
      "code": "module \\$macc (A, B, Y);\n    \n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    // CONFIG determines the layout of A, as explained below\n    parameter CONFIG = 4'b0000;\n    parameter CONFIG_WIDTH = 4;\n    \n    // In the terms used for this cell, there's mixed meanings for the term \"port\". To disambiguate:\n    // A cell port is for example the A input (it is constructed in C++ as cell->setPort(ID::A, ...))\n    // Multiplier ports are pairs of multiplier inputs (\"factors\").\n    // If the second signal in such a pair is zero length, no multiplication is necessary, and the first signal is just added to the sum.\n    input [A_WIDTH-1:0] A; // Cell port A is the concatenation of all arithmetic ports\n    input [B_WIDTH-1:0] B; // Cell port B is the concatenation of single-bit unsigned signals to be also added to the sum\n    output reg [Y_WIDTH-1:0] Y; // Output sum\n    \n    // Xilinx XSIM does not like $clog2() below..\n    function integer my_clog2;\n        input integer v;\n        begin\n            if (v > 0)\n                v = v - 1;\n            my_clog2 = 0;\n            while (v) begin\n                v = v >> 1;\n                my_clog2 = my_clog2 + 1;\n            end\n        end\n    endfunction\n    \n    // Bits that a factor's length field in CONFIG per factor in cell port A\n    localparam integer num_bits = CONFIG[3:0] > 0 ? CONFIG[3:0] : 1;\n    // Number of multiplier ports\n    localparam integer num_ports = (CONFIG_WIDTH-4) / (2 + 2*num_bits);\n    // Minium bit width of an induction variable to iterate over all bits of cell port A\n    localparam integer num_abits = my_clog2(A_WIDTH) > 0 ? my_clog2(A_WIDTH) : 1;\n    \n    // In this pseudocode, u(foo) means an unsigned int that's foo bits long.\n    // The CONFIG parameter carries the following information:\n    //    struct CONFIG {\n    //        u4 num_bits;\n    //        struct port_field {\n    //            bool is_signed;\n    //            bool is_subtract;\n    //            u(num_bits) factor1_len;\n    //            u(num_bits) factor2_len;\n    //        }[num_ports];\n    //    };\n    \n    // The A cell port carries the following information:\n    //    struct A {\n    //        u(CONFIG.port_field[0].factor1_len) port0factor1;\n    //        u(CONFIG.port_field[0].factor2_len) port0factor2;\n    //        u(CONFIG.port_field[1].factor1_len) port1factor1;\n    //        u(CONFIG.port_field[1].factor2_len) port1factor2;\n    //        ...\n    //    };\n    // and log(sizeof(A)) is num_abits.\n    // No factor1 may have a zero length.\n    // A factor2 having a zero length implies factor2 is replaced with a constant 1.\n    \n    // Additionally, B is an array of 1-bit-wide unsigned integers to also be summed up.\n    // Finally, we have:\n    // Y = port0factor1 * port0factor2 + port1factor1 * port1factor2 + ...\n    //     * B[0] + B[1] + ...\n    \n    function [2*num_ports*num_abits-1:0] get_port_offsets;\n        input [CONFIG_WIDTH-1:0] cfg;\n        integer i, cursor;\n        begin\n            cursor = 0;\n            get_port_offsets = 0;\n            for (i = 0; i < num_ports; i = i+1) begin\n                get_port_offsets[(2*i + 0)*num_abits +: num_abits] = cursor;\n                cursor = cursor + cfg[4 + i*(2 + 2*num_bits) + 2 +: num_bits];\n                get_port_offsets[(2*i + 1)*num_abits +: num_abits] = cursor;\n                cursor = cursor + cfg[4 + i*(2 + 2*num_bits) + 2 + num_bits +: num_bits];\n            end\n        end\n    endfunction\n    \n    localparam [2*num_ports*num_abits-1:0] port_offsets = get_port_offsets(CONFIG);\n    \n    `define PORT_IS_SIGNED   (0 + CONFIG[4 + i*(2 + 2*num_bits)])\n    `define PORT_DO_SUBTRACT (0 + CONFIG[4 + i*(2 + 2*num_bits) + 1])\n    `define PORT_SIZE_A      (0 + CONFIG[4 + i*(2 + 2*num_bits) + 2 +: num_bits])\n    `define PORT_SIZE_B      (0 + CONFIG[4 + i*(2 + 2*num_bits) + 2 + num_bits +: num_bits])\n    `define PORT_OFFSET_A    (0 + port_offsets[2*i*num_abits +: num_abits])\n    `define PORT_OFFSET_B    (0 + port_offsets[2*i*num_abits + num_abits +: num_abits])\n    \n    integer i, j;\n    reg [Y_WIDTH-1:0] tmp_a, tmp_b;\n    \n    always @* begin\n        Y = 0;\n        for (i = 0; i < num_ports; i = i+1)\n        begin\n            tmp_a = 0;\n            tmp_b = 0;\n    \n            for (j = 0; j < `PORT_SIZE_A; j = j+1)\n                tmp_a[j] = A[`PORT_OFFSET_A + j];\n    \n            if (`PORT_IS_SIGNED && `PORT_SIZE_A > 0)\n                for (j = `PORT_SIZE_A; j < Y_WIDTH; j = j+1)\n                    tmp_a[j] = tmp_a[`PORT_SIZE_A-1];\n    \n            for (j = 0; j < `PORT_SIZE_B; j = j+1)\n                tmp_b[j] = A[`PORT_OFFSET_B + j];\n    \n            if (`PORT_IS_SIGNED && `PORT_SIZE_B > 0)\n                for (j = `PORT_SIZE_B; j < Y_WIDTH; j = j+1)\n                    tmp_b[j] = tmp_b[`PORT_SIZE_B-1];\n    \n            if (`PORT_SIZE_B > 0)\n                tmp_a = tmp_a * tmp_b;\n    \n            if (`PORT_DO_SUBTRACT)\n                Y = Y - tmp_a;\n            else\n                Y = Y + tmp_a;\n        end\n        for (i = 0; i < B_WIDTH; i = i+1) begin\n            Y = Y + B[i];\n        end\n    end\n    \n    `undef PORT_IS_SIGNED\n    `undef PORT_DO_SUBTRACT\n    `undef PORT_SIZE_A\n    `undef PORT_SIZE_B\n    `undef PORT_OFFSET_A\n    `undef PORT_OFFSET_B\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$mem": {
      "title": "",
      "ports": "(RD_CLK, RD_EN, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA)",
      "source": "simlib.v:2623",
      "desc": "",
      "code": "module \\$mem (RD_CLK, RD_EN, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA);\n    \n    parameter MEMID = \"\";\n    parameter signed SIZE = 4;\n    parameter signed OFFSET = 0;\n    parameter signed ABITS = 2;\n    parameter signed WIDTH = 8;\n    parameter signed INIT = 1'bx;\n    \n    parameter signed RD_PORTS = 1;\n    parameter RD_CLK_ENABLE = 1'b1;\n    parameter RD_CLK_POLARITY = 1'b1;\n    parameter RD_TRANSPARENT = 1'b1;\n    \n    parameter signed WR_PORTS = 1;\n    parameter WR_CLK_ENABLE = 1'b1;\n    parameter WR_CLK_POLARITY = 1'b1;\n    \n    input [RD_PORTS-1:0] RD_CLK;\n    input [RD_PORTS-1:0] RD_EN;\n    input [RD_PORTS*ABITS-1:0] RD_ADDR;\n    output reg [RD_PORTS*WIDTH-1:0] RD_DATA;\n    \n    input [WR_PORTS-1:0] WR_CLK;\n    input [WR_PORTS*WIDTH-1:0] WR_EN;\n    input [WR_PORTS*ABITS-1:0] WR_ADDR;\n    input [WR_PORTS*WIDTH-1:0] WR_DATA;\n    \n    reg [WIDTH-1:0] memory [SIZE-1:0];\n    \n    integer i, j;\n    reg [WR_PORTS-1:0] LAST_WR_CLK;\n    reg [RD_PORTS-1:0] LAST_RD_CLK;\n    \n    function port_active;\n        input clk_enable;\n        input clk_polarity;\n        input last_clk;\n        input this_clk;\n        begin\n            casez ({clk_enable, clk_polarity, last_clk, this_clk})\n                4'b0???: port_active = 1;\n                4'b1101: port_active = 1;\n                4'b1010: port_active = 1;\n                default: port_active = 0;\n            endcase\n        end\n    endfunction\n    \n    initial begin\n        for (i = 0; i < SIZE; i = i+1)\n            memory[i] = INIT >>> (i*WIDTH);\n    end\n    \n    always @(RD_CLK, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA) begin\n    `ifdef SIMLIB_MEMDELAY\n        #`SIMLIB_MEMDELAY;\n    `endif\n        for (i = 0; i < RD_PORTS; i = i+1) begin\n            if (!RD_TRANSPARENT[i] && RD_CLK_ENABLE[i] && RD_EN[i] && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i], LAST_RD_CLK[i], RD_CLK[i])) begin\n                // $display(\"Read from %s: addr=%b data=%b\", MEMID, RD_ADDR[i*ABITS +: ABITS],  memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET]);\n                RD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];\n            end\n        end\n    \n        for (i = 0; i < WR_PORTS; i = i+1) begin\n            if (port_active(WR_CLK_ENABLE[i], WR_CLK_POLARITY[i], LAST_WR_CLK[i], WR_CLK[i]))\n                for (j = 0; j < WIDTH; j = j+1)\n                    if (WR_EN[i*WIDTH+j]) begin\n                        // $display(\"Write to %s: addr=%b data=%b\", MEMID, WR_ADDR[i*ABITS +: ABITS], WR_DATA[i*WIDTH+j]);\n                        memory[WR_ADDR[i*ABITS +: ABITS] - OFFSET][j] = WR_DATA[i*WIDTH+j];\n                    end\n        end\n    \n        for (i = 0; i < RD_PORTS; i = i+1) begin\n            if ((RD_TRANSPARENT[i] || !RD_CLK_ENABLE[i]) && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i], LAST_RD_CLK[i], RD_CLK[i])) begin\n                // $display(\"Transparent read from %s: addr=%b data=%b\", MEMID, RD_ADDR[i*ABITS +: ABITS],  memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET]);\n                RD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];\n            end\n        end\n    \n        LAST_RD_CLK <= RD_CLK;\n        LAST_WR_CLK <= WR_CLK;\n    end\n    \nendmodule",
      "inputs": ["\\WR_DATA", "\\WR_ADDR", "\\WR_EN", "\\WR_CLK", "\\RD_ADDR", "\\RD_EN", "\\RD_CLK"],
      "outputs": ["\\RD_DATA"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$mem_v2": {
      "title": "",
      "ports": "(RD_CLK, RD_EN, RD_ARST, RD_SRST, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA)",
      "source": "simlib.v:2712",
      "desc": "",
      "code": "module \\$mem_v2 (RD_CLK, RD_EN, RD_ARST, RD_SRST, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA);\n    \n    parameter MEMID = \"\";\n    parameter signed SIZE = 4;\n    parameter signed OFFSET = 0;\n    parameter signed ABITS = 2;\n    parameter signed WIDTH = 8;\n    parameter signed INIT = 1'bx;\n    \n    parameter signed RD_PORTS = 1;\n    parameter RD_CLK_ENABLE = 1'b1;\n    parameter RD_CLK_POLARITY = 1'b1;\n    parameter RD_TRANSPARENCY_MASK = 1'b0;\n    parameter RD_COLLISION_X_MASK = 1'b0;\n    parameter RD_WIDE_CONTINUATION = 1'b0;\n    parameter RD_CE_OVER_SRST = 1'b0;\n    parameter RD_ARST_VALUE = 1'b0;\n    parameter RD_SRST_VALUE = 1'b0;\n    parameter RD_INIT_VALUE = 1'b0;\n    \n    parameter signed WR_PORTS = 1;\n    parameter WR_CLK_ENABLE = 1'b1;\n    parameter WR_CLK_POLARITY = 1'b1;\n    parameter WR_PRIORITY_MASK = 1'b0;\n    parameter WR_WIDE_CONTINUATION = 1'b0;\n    \n    input [RD_PORTS-1:0] RD_CLK;\n    input [RD_PORTS-1:0] RD_EN;\n    input [RD_PORTS-1:0] RD_ARST;\n    input [RD_PORTS-1:0] RD_SRST;\n    input [RD_PORTS*ABITS-1:0] RD_ADDR;\n    output reg [RD_PORTS*WIDTH-1:0] RD_DATA;\n    \n    input [WR_PORTS-1:0] WR_CLK;\n    input [WR_PORTS*WIDTH-1:0] WR_EN;\n    input [WR_PORTS*ABITS-1:0] WR_ADDR;\n    input [WR_PORTS*WIDTH-1:0] WR_DATA;\n    \n    reg [WIDTH-1:0] memory [SIZE-1:0];\n    \n    integer i, j, k;\n    reg [WR_PORTS-1:0] LAST_WR_CLK;\n    reg [RD_PORTS-1:0] LAST_RD_CLK;\n    \n    function port_active;\n        input clk_enable;\n        input clk_polarity;\n        input last_clk;\n        input this_clk;\n        begin\n            casez ({clk_enable, clk_polarity, last_clk, this_clk})\n                4'b0???: port_active = 1;\n                4'b1101: port_active = 1;\n                4'b1010: port_active = 1;\n                default: port_active = 0;\n            endcase\n        end\n    endfunction\n    \n    initial begin\n        for (i = 0; i < SIZE; i = i+1)\n            memory[i] = INIT >>> (i*WIDTH);\n        RD_DATA = RD_INIT_VALUE;\n    end\n    \n    always @(RD_CLK, RD_ARST, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA) begin\n    `ifdef SIMLIB_MEMDELAY\n        #`SIMLIB_MEMDELAY;\n    `endif\n        for (i = 0; i < RD_PORTS; i = i+1) begin\n            if (RD_CLK_ENABLE[i] && RD_EN[i] && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i], LAST_RD_CLK[i], RD_CLK[i])) begin\n                // $display(\"Read from %s: addr=%b data=%b\", MEMID, RD_ADDR[i*ABITS +: ABITS],  memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET]);\n                RD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];\n    \n                for (j = 0; j < WR_PORTS; j = j+1) begin\n                    if (RD_TRANSPARENCY_MASK[i*WR_PORTS + j] && port_active(WR_CLK_ENABLE[j], WR_CLK_POLARITY[j], LAST_WR_CLK[j], WR_CLK[j]) && RD_ADDR[i*ABITS +: ABITS] == WR_ADDR[j*ABITS +: ABITS])\n                        for (k = 0; k < WIDTH; k = k+1)\n                            if (WR_EN[j*WIDTH+k])\n                                RD_DATA[i*WIDTH+k] <= WR_DATA[j*WIDTH+k];\n                    if (RD_COLLISION_X_MASK[i*WR_PORTS + j] && port_active(WR_CLK_ENABLE[j], WR_CLK_POLARITY[j], LAST_WR_CLK[j], WR_CLK[j]) && RD_ADDR[i*ABITS +: ABITS] == WR_ADDR[j*ABITS +: ABITS])\n                        for (k = 0; k < WIDTH; k = k+1)\n                            if (WR_EN[j*WIDTH+k])\n                                RD_DATA[i*WIDTH+k] <= 1'bx;\n                end\n            end\n        end\n    \n        for (i = 0; i < WR_PORTS; i = i+1) begin\n            if (port_active(WR_CLK_ENABLE[i], WR_CLK_POLARITY[i], LAST_WR_CLK[i], WR_CLK[i]))\n                for (j = 0; j < WIDTH; j = j+1)\n                    if (WR_EN[i*WIDTH+j]) begin\n                        // $display(\"Write to %s: addr=%b data=%b\", MEMID, WR_ADDR[i*ABITS +: ABITS], WR_DATA[i*WIDTH+j]);\n                        memory[WR_ADDR[i*ABITS +: ABITS] - OFFSET][j] = WR_DATA[i*WIDTH+j];\n                    end\n        end\n    \n        for (i = 0; i < RD_PORTS; i = i+1) begin\n            if (!RD_CLK_ENABLE[i]) begin\n                // $display(\"Combinatorial read from %s: addr=%b data=%b\", MEMID, RD_ADDR[i*ABITS +: ABITS],  memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET]);\n                RD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];\n            end\n        end\n    \n        for (i = 0; i < RD_PORTS; i = i+1) begin\n            if (RD_SRST[i] && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i], LAST_RD_CLK[i], RD_CLK[i]) && (RD_EN[i] || !RD_CE_OVER_SRST[i]))\n                RD_DATA[i*WIDTH +: WIDTH] <= RD_SRST_VALUE[i*WIDTH +: WIDTH];\n            if (RD_ARST[i])\n                RD_DATA[i*WIDTH +: WIDTH] <= RD_ARST_VALUE[i*WIDTH +: WIDTH];\n        end\n    \n        LAST_RD_CLK <= RD_CLK;\n        LAST_WR_CLK <= WR_CLK;\n    end\n    \nendmodule",
      "inputs": ["\\WR_DATA", "\\WR_ADDR", "\\WR_EN", "\\WR_CLK", "\\RD_ADDR", "\\RD_SRST", "\\RD_ARST", "\\RD_EN", "\\RD_CLK"],
      "outputs": ["\\RD_DATA"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$meminit": {
      "title": "",
      "ports": "(ADDR, DATA)",
      "source": "simlib.v:2574",
      "desc": "",
      "code": "module \\$meminit (ADDR, DATA);\n    \n    parameter MEMID = \"\";\n    parameter ABITS = 8;\n    parameter WIDTH = 8;\n    parameter WORDS = 1;\n    \n    parameter PRIORITY = 0;\n    \n    input [ABITS-1:0] ADDR;\n    input [WORDS*WIDTH-1:0] DATA;\n    \n    initial begin\n        if (MEMID != \"\") begin\n            $display(\"ERROR: Found non-simulatable instance of $meminit!\");\n            $finish;\n        end\n    end\n    \nendmodule",
      "inputs": ["\\DATA", "\\ADDR"],
      "outputs": [],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$meminit_v2": {
      "title": "",
      "ports": "(ADDR, DATA, EN)",
      "source": "simlib.v:2598",
      "desc": "",
      "code": "module \\$meminit_v2 (ADDR, DATA, EN);\n    \n    parameter MEMID = \"\";\n    parameter ABITS = 8;\n    parameter WIDTH = 8;\n    parameter WORDS = 1;\n    \n    parameter PRIORITY = 0;\n    \n    input [ABITS-1:0] ADDR;\n    input [WORDS*WIDTH-1:0] DATA;\n    input [WIDTH-1:0] EN;\n    \n    initial begin\n        if (MEMID != \"\") begin\n            $display(\"ERROR: Found non-simulatable instance of $meminit_v2!\");\n            $finish;\n        end\n    end\n    \nendmodule",
      "inputs": ["\\EN", "\\DATA", "\\ADDR"],
      "outputs": [],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$memrd": {
      "title": "",
      "ports": "(CLK, EN, ADDR, DATA)",
      "source": "simlib.v:2465",
      "desc": "",
      "code": "module \\$memrd (CLK, EN, ADDR, DATA);\n    \n    parameter MEMID = \"\";\n    parameter ABITS = 8;\n    parameter WIDTH = 8;\n    \n    parameter CLK_ENABLE = 0;\n    parameter CLK_POLARITY = 0;\n    parameter TRANSPARENT = 0;\n    \n    input CLK, EN;\n    input [ABITS-1:0] ADDR;\n    output [WIDTH-1:0] DATA;\n    \n    initial begin\n        if (MEMID != \"\") begin\n            $display(\"ERROR: Found non-simulatable instance of $memrd!\");\n            $finish;\n        end\n    end\n    \nendmodule",
      "inputs": ["\\ADDR", "\\EN", "\\CLK"],
      "outputs": ["\\DATA"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$memrd_v2": {
      "title": "",
      "ports": "(CLK, EN, ARST, SRST, ADDR, DATA)",
      "source": "simlib.v:2490",
      "desc": "",
      "code": "module \\$memrd_v2 (CLK, EN, ARST, SRST, ADDR, DATA);\n    \n    parameter MEMID = \"\";\n    parameter ABITS = 8;\n    parameter WIDTH = 8;\n    \n    parameter CLK_ENABLE = 0;\n    parameter CLK_POLARITY = 0;\n    parameter TRANSPARENCY_MASK = 0;\n    parameter COLLISION_X_MASK = 0;\n    parameter ARST_VALUE = 0;\n    parameter SRST_VALUE = 0;\n    parameter INIT_VALUE = 0;\n    parameter CE_OVER_SRST = 0;\n    \n    input CLK, EN, ARST, SRST;\n    input [ABITS-1:0] ADDR;\n    output [WIDTH-1:0] DATA;\n    \n    initial begin\n        if (MEMID != \"\") begin\n            $display(\"ERROR: Found non-simulatable instance of $memrd_v2!\");\n            $finish;\n        end\n    end\n    \nendmodule",
      "inputs": ["\\ADDR", "\\SRST", "\\ARST", "\\EN", "\\CLK"],
      "outputs": ["\\DATA"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$memwr": {
      "title": "",
      "ports": "(CLK, EN, ADDR, DATA)",
      "source": "simlib.v:2521",
      "desc": "",
      "code": "module \\$memwr (CLK, EN, ADDR, DATA);\n    \n    parameter MEMID = \"\";\n    parameter ABITS = 8;\n    parameter WIDTH = 8;\n    \n    parameter CLK_ENABLE = 0;\n    parameter CLK_POLARITY = 0;\n    parameter PRIORITY = 0;\n    \n    input CLK;\n    input [WIDTH-1:0] EN;\n    input [ABITS-1:0] ADDR;\n    input [WIDTH-1:0] DATA;\n    \n    initial begin\n        if (MEMID != \"\") begin\n            $display(\"ERROR: Found non-simulatable instance of $memwr!\");\n            $finish;\n        end\n    end\n    \nendmodule",
      "inputs": ["\\DATA", "\\ADDR", "\\EN", "\\CLK"],
      "outputs": [],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$memwr_v2": {
      "title": "",
      "ports": "(CLK, EN, ADDR, DATA)",
      "source": "simlib.v:2546",
      "desc": "",
      "code": "module \\$memwr_v2 (CLK, EN, ADDR, DATA);\n    \n    parameter MEMID = \"\";\n    parameter ABITS = 8;\n    parameter WIDTH = 8;\n    \n    parameter CLK_ENABLE = 0;\n    parameter CLK_POLARITY = 0;\n    parameter PORTID = 0;\n    parameter PRIORITY_MASK = 0;\n    \n    input CLK;\n    input [WIDTH-1:0] EN;\n    input [ABITS-1:0] ADDR;\n    input [WIDTH-1:0] DATA;\n    \n    initial begin\n        if (MEMID != \"\") begin\n            $display(\"ERROR: Found non-simulatable instance of $memwr_v2!\");\n            $finish;\n        end\n    end\n    \nendmodule",
      "inputs": ["\\DATA", "\\ADDR", "\\EN", "\\CLK"],
      "outputs": [],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$mod": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:1124",
      "desc": "Modulo/remainder of division with truncated result (rounded towards 0).\n\nInvariant: $div(A, B) * B + $mod(A, B) == A",
      "code": "module \\$mod (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) % $signed(B);\n        end else begin:BLOCK2\n            assign Y = A % B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$modfloor": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:1195",
      "desc": "Modulo/remainder of division with floored result (rounded towards negative infinity).\n\nInvariant: $divfloor(A, B) * B + $modfloor(A, B) == A",
      "code": "module \\$modfloor (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            localparam WIDTH = B_WIDTH >= Y_WIDTH ? B_WIDTH : Y_WIDTH;\n            wire [WIDTH-1:0] B_buf, Y_trunc;\n            assign B_buf = $signed(B);\n            assign Y_trunc = $signed(A) % $signed(B);\n            // flooring mod is the same as truncating mod for positive division results (A and B have\n            // the same sign), as well as when there's no remainder.\n            // For all other cases, they behave as `floor - trunc = B`\n            assign Y = (A[A_WIDTH-1] == B[B_WIDTH-1]) || Y_trunc == 0 ? Y_trunc : $signed(B_buf) + $signed(Y_trunc);\n        end else begin:BLOCK2\n            // no difference between truncating and flooring for unsigned\n            assign Y = A % B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$mul": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:909",
      "desc": "",
      "code": "module \\$mul (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) * $signed(B);\n        end else begin:BLOCK2\n            assign Y = A * B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$mux": {
      "title": "",
      "ports": "(A, B, S, Y)",
      "source": "simlib.v:1361",
      "desc": "",
      "code": "module \\$mux (A, B, S, Y);\n    \n    parameter WIDTH = 0;\n    \n    input [WIDTH-1:0] A, B;\n    input S;\n    output [WIDTH-1:0] Y;\n    \n    assign Y = S ? B : A;\n    \nendmodule",
      "inputs": ["\\S", "\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$ne": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:734",
      "desc": "",
      "code": "module \\$ne (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) != $signed(B);\n        end else begin:BLOCK2\n            assign Y = A != B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$neg": {
      "title": "",
      "ports": "(A, Y)",
      "source": "simlib.v:98",
      "desc": "An arithmetic inverter. This corresponds to the Verilog unary prefix '-' operator.",
      "code": "module \\$neg (A, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED) begin:BLOCK1\n            assign Y = -$signed(A);\n        end else begin:BLOCK2\n            assign Y = -A;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$nex": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:784",
      "desc": "",
      "code": "module \\$nex (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) !== $signed(B);\n        end else begin:BLOCK2\n            assign Y = A !== B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$not": {
      "title": "Bit-wise inverter",
      "ports": "(A, Y)",
      "source": "simlib.v:41",
      "desc": "This corresponds to the Verilog unary prefix '~' operator.",
      "code": "module \\$not (A, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED) begin:BLOCK1\n            assign Y = ~$signed(A);\n        end else begin:BLOCK2\n            assign Y = ~A;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$or": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:157",
      "desc": "A bit-wise OR. This corresponds to the Verilog '|' operator.",
      "code": "module \\$or (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) | $signed(B);\n        end else begin:BLOCK2\n            assign Y = A | B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$original_tag": {
      "title": "",
      "ports": "(A, Y)",
      "source": "simlib.v:2875",
      "desc": "",
      "code": "module \\$original_tag (A, Y);\n    \n    parameter TAG = \"\";\n    parameter WIDTH = 0;\n    \n    input [WIDTH-1:0] A;\n    output [WIDTH-1:0] Y;\n    \n    assign Y = A;\n    \nendmodule",
      "inputs": ["\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$overwrite_tag": {
      "title": "",
      "ports": "(A, SET, CLR)",
      "source": "simlib.v:2862",
      "desc": "",
      "code": "module \\$overwrite_tag (A, SET, CLR);\n    \n    parameter TAG = \"\";\n    parameter WIDTH = 0;\n    \n    input [WIDTH-1:0] A;\n    input [WIDTH-1:0] SET;\n    input [WIDTH-1:0] CLR;\n    \nendmodule",
      "inputs": ["\\CLR", "\\SET", "\\A"],
      "outputs": [],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$pmux": {
      "title": "",
      "ports": "(A, B, S, Y)",
      "source": "simlib.v:1404",
      "desc": "",
      "code": "module \\$pmux (A, B, S, Y);\n    \n    parameter WIDTH = 0;\n    parameter S_WIDTH = 0;\n    \n    input [WIDTH-1:0] A;\n    input [WIDTH*S_WIDTH-1:0] B;\n    input [S_WIDTH-1:0] S;\n    output reg [WIDTH-1:0] Y;\n    \n    integer i;\n    reg found_active_sel_bit;\n    \n    always @* begin\n        Y = A;\n        found_active_sel_bit = 0;\n        for (i = 0; i < S_WIDTH; i = i+1)\n            case (S[i])\n                1'b1: begin\n                    Y = found_active_sel_bit ? 'bx : B >> (WIDTH*i);\n                    found_active_sel_bit = 1;\n                end\n                1'b0: ;\n                1'bx: begin\n                    Y = 'bx;\n                    found_active_sel_bit = 'bx;\n                end\n            endcase\n    end\n    \nendmodule",
      "inputs": ["\\S", "\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$pos": {
      "title": "",
      "ports": "(A, Y)",
      "source": "simlib.v:70",
      "desc": "A buffer. This corresponds to the Verilog unary prefix '+' operator.",
      "code": "module \\$pos (A, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED) begin:BLOCK1\n            assign Y = $signed(A);\n        end else begin:BLOCK2\n            assign Y = A;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$pow": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:1229",
      "desc": "",
      "code": "module \\$pow (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) ** $signed(B);\n        end else if (A_SIGNED) begin:BLOCK2\n            assign Y = $signed(A) ** B;\n        end else if (B_SIGNED) begin:BLOCK3\n            assign Y = A ** $signed(B);\n        end else begin:BLOCK4\n            assign Y = A ** B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$print": {
      "title": "",
      "ports": "(EN, TRG, ARGS)",
      "source": "simlib.v:1911",
      "desc": "",
      "code": "module \\$print (EN, TRG, ARGS);\n    \n    parameter PRIORITY = 0;\n    \n    parameter FORMAT = \"\";\n    parameter ARGS_WIDTH = 0;\n    \n    parameter TRG_ENABLE = 1;\n    parameter TRG_WIDTH = 0;\n    parameter TRG_POLARITY = 0;\n    \n    input EN;\n    input [TRG_WIDTH-1:0] TRG;\n    input [ARGS_WIDTH-1:0] ARGS;\n    \nendmodule",
      "inputs": ["\\TRG", "\\ARGS", "\\EN"],
      "outputs": [],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$reduce_and": {
      "title": "",
      "ports": "(A, Y)",
      "source": "simlib.v:250",
      "desc": "An AND reduction. This corresponds to the Verilog unary prefix '&' operator.",
      "code": "module \\$reduce_and (A, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED) begin:BLOCK1\n            assign Y = &$signed(A);\n        end else begin:BLOCK2\n            assign Y = &A;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$reduce_bool": {
      "title": "",
      "ports": "(A, Y)",
      "source": "simlib.v:363",
      "desc": "An OR reduction. This cell type is used instead of $reduce_or when a signal is\nimplicitly converted to a boolean signal, e.g. for operands of '&&' and '||'.",
      "code": "module \\$reduce_bool (A, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED) begin:BLOCK1\n            assign Y = !(!$signed(A));\n        end else begin:BLOCK2\n            assign Y = !(!A);\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$reduce_or": {
      "title": "",
      "ports": "(A, Y)",
      "source": "simlib.v:278",
      "desc": "An OR reduction. This corresponds to the Verilog unary prefix '|' operator.",
      "code": "module \\$reduce_or (A, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED) begin:BLOCK1\n            assign Y = |$signed(A);\n        end else begin:BLOCK2\n            assign Y = |A;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$reduce_xnor": {
      "title": "",
      "ports": "(A, Y)",
      "source": "simlib.v:334",
      "desc": "A XNOR reduction. This corresponds to the Verilog unary prefix '~^' operator.",
      "code": "module \\$reduce_xnor (A, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED) begin:BLOCK1\n            assign Y = ~^$signed(A);\n        end else begin:BLOCK2\n            assign Y = ~^A;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$reduce_xor": {
      "title": "",
      "ports": "(A, Y)",
      "source": "simlib.v:306",
      "desc": "A XOR reduction. This corresponds to the Verilog unary prefix '^' operator.",
      "code": "module \\$reduce_xor (A, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED) begin:BLOCK1\n            assign Y = ^$signed(A);\n        end else begin:BLOCK2\n            assign Y = ^A;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$scopeinfo": {
      "title": "",
      "ports": "()",
      "source": "simlib.v:2903",
      "desc": "",
      "code": "module \\$scopeinfo ();\n    \n    parameter TYPE = \"\";\n    \nendmodule",
      "inputs": [],
      "outputs": [],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$sdff": {
      "title": "",
      "ports": "(CLK, SRST, D, Q)",
      "source": "simlib.v:2162",
      "desc": "",
      "code": "module \\$sdff (CLK, SRST, D, Q);\n    \n    parameter WIDTH = 0;\n    parameter CLK_POLARITY = 1'b1;\n    parameter SRST_POLARITY = 1'b1;\n    parameter SRST_VALUE = 0;\n    \n    input CLK, SRST;\n    input [WIDTH-1:0] D;\n    output reg [WIDTH-1:0] Q;\n    wire pos_clk = CLK == CLK_POLARITY;\n    wire pos_srst = SRST == SRST_POLARITY;\n    \n    always @(posedge pos_clk) begin\n        if (pos_srst)\n            Q <= SRST_VALUE;\n        else\n            Q <= D;\n    end\n    \nendmodule",
      "inputs": ["\\D", "\\SRST", "\\CLK"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$sdffce": {
      "title": "",
      "ports": "(CLK, SRST, EN, D, Q)",
      "source": "simlib.v:2265",
      "desc": "",
      "code": "module \\$sdffce (CLK, SRST, EN, D, Q);\n    \n    parameter WIDTH = 0;\n    parameter CLK_POLARITY = 1'b1;\n    parameter EN_POLARITY = 1'b1;\n    parameter SRST_POLARITY = 1'b1;\n    parameter SRST_VALUE = 0;\n    \n    input CLK, SRST, EN;\n    input [WIDTH-1:0] D;\n    output reg [WIDTH-1:0] Q;\n    wire pos_clk = CLK == CLK_POLARITY;\n    wire pos_srst = SRST == SRST_POLARITY;\n    \n    always @(posedge pos_clk) begin\n        if (EN == EN_POLARITY) begin\n            if (pos_srst)\n                Q <= SRST_VALUE;\n            else\n                Q <= D;\n        end\n    end\n    \nendmodule",
      "inputs": ["\\EN", "\\D", "\\SRST", "\\CLK"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$sdffe": {
      "title": "",
      "ports": "(CLK, SRST, EN, D, Q)",
      "source": "simlib.v:2239",
      "desc": "",
      "code": "module \\$sdffe (CLK, SRST, EN, D, Q);\n    \n    parameter WIDTH = 0;\n    parameter CLK_POLARITY = 1'b1;\n    parameter EN_POLARITY = 1'b1;\n    parameter SRST_POLARITY = 1'b1;\n    parameter SRST_VALUE = 0;\n    \n    input CLK, SRST, EN;\n    input [WIDTH-1:0] D;\n    output reg [WIDTH-1:0] Q;\n    wire pos_clk = CLK == CLK_POLARITY;\n    wire pos_srst = SRST == SRST_POLARITY;\n    \n    always @(posedge pos_clk) begin\n        if (pos_srst)\n            Q <= SRST_VALUE;\n        else if (EN == EN_POLARITY)\n            Q <= D;\n    end\n    \nendmodule",
      "inputs": ["\\EN", "\\D", "\\SRST", "\\CLK"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$set_tag": {
      "title": "",
      "ports": "(A, SET, CLR, Y)",
      "source": "simlib.v:2832",
      "desc": "",
      "code": "module \\$set_tag (A, SET, CLR, Y);\n    \n    parameter TAG = \"\";\n    parameter WIDTH = 0;\n    \n    input [WIDTH-1:0] A;\n    input [WIDTH-1:0] SET;\n    input [WIDTH-1:0] CLR;\n    output [WIDTH-1:0] Y;\n    \n    assign Y = A;\n    \nendmodule",
      "inputs": ["\\CLR", "\\SET", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$shift": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:486",
      "desc": "",
      "code": "module \\$shift (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED) begin:BLOCK1\n            if (B_SIGNED) begin:BLOCK2\n                assign Y = $signed(B) < 0 ? $signed(A) << -B : $signed(A) >> B;\n            end else begin:BLOCK3\n                assign Y = $signed(A) >> B;\n            end\n        end else begin:BLOCK4\n            if (B_SIGNED) begin:BLOCK5\n                assign Y = $signed(B) < 0 ? A << -B : A >> B;\n            end else begin:BLOCK6\n                assign Y = A >> B;\n            end\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$shiftx": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:519",
      "desc": "",
      "code": "module \\$shiftx (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (Y_WIDTH > 0)\n            if (B_SIGNED) begin:BLOCK1\n                assign Y = A[$signed(B) +: Y_WIDTH];\n            end else begin:BLOCK2\n                assign Y = A[B +: Y_WIDTH];\n            end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$shl": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:386",
      "desc": "",
      "code": "module \\$shl (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) << B;\n        end else begin:BLOCK2\n            assign Y = A << B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$shr": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:411",
      "desc": "",
      "code": "module \\$shr (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) >> B;\n        end else begin:BLOCK2\n            assign Y = A >> B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$slice": {
      "title": "",
      "ports": "(A, Y)",
      "source": "simlib.v:1330",
      "desc": "",
      "code": "module \\$slice (A, Y);\n    \n    parameter OFFSET = 0;\n    parameter A_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    output [Y_WIDTH-1:0] Y;\n    \n    assign Y = A >> OFFSET;\n    \nendmodule",
      "inputs": ["\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$sop": {
      "title": "",
      "ports": "(A, Y)",
      "source": "simlib.v:1477",
      "desc": "",
      "code": "module \\$sop (A, Y);\n    \n    parameter WIDTH = 0;\n    parameter DEPTH = 0;\n    parameter TABLE = 0;\n    \n    input [WIDTH-1:0] A;\n    output reg Y;\n    \n    integer i, j;\n    reg match;\n    \n    always @* begin\n        Y = 0;\n        for (i = 0; i < DEPTH; i=i+1) begin\n            match = 1;\n            for (j = 0; j < WIDTH; j=j+1) begin\n                if (TABLE[2*WIDTH*i + 2*j + 0] && A[j]) match = 0;\n                if (TABLE[2*WIDTH*i + 2*j + 1] && !A[j]) match = 0;\n            end\n            if (match) Y = 1;\n        end\n    end\n    \nendmodule",
      "inputs": ["\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$specify2": {
      "title": "",
      "ports": "(EN, SRC, DST)",
      "source": "simlib.v:1521",
      "desc": "",
      "code": "module \\$specify2 (EN, SRC, DST);\n    \n    parameter FULL = 0;\n    parameter SRC_WIDTH = 1;\n    parameter DST_WIDTH = 1;\n    \n    parameter SRC_DST_PEN = 0;\n    parameter SRC_DST_POL = 0;\n    \n    parameter T_RISE_MIN = 0;\n    parameter T_RISE_TYP = 0;\n    parameter T_RISE_MAX = 0;\n    \n    parameter T_FALL_MIN = 0;\n    parameter T_FALL_TYP = 0;\n    parameter T_FALL_MAX = 0;\n    \n    input EN;\n    input [SRC_WIDTH-1:0] SRC;\n    input [DST_WIDTH-1:0] DST;\n    \n    localparam SD = SRC_DST_PEN ? (SRC_DST_POL ? 1 : 2) : 0;\n    \n    `ifdef SIMLIB_SPECIFY\n    specify\n        if (EN && SD==0 && !FULL) (SRC  => DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && SD==0 &&  FULL) (SRC  *> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && SD==1 && !FULL) (SRC +=> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && SD==1 &&  FULL) (SRC +*> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && SD==2 && !FULL) (SRC -=> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && SD==2 &&  FULL) (SRC -*> DST) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n    endspecify\n    `endif\n    \nendmodule",
      "inputs": ["\\DST", "\\SRC", "\\EN"],
      "outputs": [],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$specify3": {
      "title": "",
      "ports": "(EN, SRC, DST, DAT)",
      "source": "simlib.v:1560",
      "desc": "",
      "code": "module \\$specify3 (EN, SRC, DST, DAT);\n    \n    parameter FULL = 0;\n    parameter SRC_WIDTH = 1;\n    parameter DST_WIDTH = 1;\n    \n    parameter EDGE_EN = 0;\n    parameter EDGE_POL = 0;\n    \n    parameter SRC_DST_PEN = 0;\n    parameter SRC_DST_POL = 0;\n    \n    parameter DAT_DST_PEN = 0;\n    parameter DAT_DST_POL = 0;\n    \n    parameter T_RISE_MIN = 0;\n    parameter T_RISE_TYP = 0;\n    parameter T_RISE_MAX = 0;\n    \n    parameter T_FALL_MIN = 0;\n    parameter T_FALL_TYP = 0;\n    parameter T_FALL_MAX = 0;\n    \n    input EN;\n    input [SRC_WIDTH-1:0] SRC;\n    input [DST_WIDTH-1:0] DST, DAT;\n    \n    localparam ED = EDGE_EN     ? (EDGE_POL    ? 1 : 2) : 0;\n    localparam SD = SRC_DST_PEN ? (SRC_DST_POL ? 1 : 2) : 0;\n    localparam DD = DAT_DST_PEN ? (DAT_DST_POL ? 1 : 2) : 0;\n    \n    `ifdef SIMLIB_SPECIFY\n    specify\n        // DD=0\n    \n        if (EN && DD==0 && SD==0 && ED==0 && !FULL) (        SRC  => (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==0 && SD==0 && ED==0 &&  FULL) (        SRC  *> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==0 && SD==0 && ED==1 && !FULL) (posedge SRC  => (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==0 && SD==0 && ED==1 &&  FULL) (posedge SRC  *> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==0 && SD==0 && ED==2 && !FULL) (negedge SRC  => (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==0 && SD==0 && ED==2 &&  FULL) (negedge SRC  *> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n    \n        if (EN && DD==0 && SD==1 && ED==0 && !FULL) (        SRC +=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==0 && SD==1 && ED==0 &&  FULL) (        SRC +*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==0 && SD==1 && ED==1 && !FULL) (posedge SRC +=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==0 && SD==1 && ED==1 &&  FULL) (posedge SRC +*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==0 && SD==1 && ED==2 && !FULL) (negedge SRC +=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==0 && SD==1 && ED==2 &&  FULL) (negedge SRC +*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n    \n        if (EN && DD==0 && SD==2 && ED==0 && !FULL) (        SRC -=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==0 && SD==2 && ED==0 &&  FULL) (        SRC -*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==0 && SD==2 && ED==1 && !FULL) (posedge SRC -=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==0 && SD==2 && ED==1 &&  FULL) (posedge SRC -*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==0 && SD==2 && ED==2 && !FULL) (negedge SRC -=> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==0 && SD==2 && ED==2 &&  FULL) (negedge SRC -*> (DST  : DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n    \n        // DD=1\n    \n        if (EN && DD==1 && SD==0 && ED==0 && !FULL) (        SRC  => (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==1 && SD==0 && ED==0 &&  FULL) (        SRC  *> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==1 && SD==0 && ED==1 && !FULL) (posedge SRC  => (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==1 && SD==0 && ED==1 &&  FULL) (posedge SRC  *> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==1 && SD==0 && ED==2 && !FULL) (negedge SRC  => (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==1 && SD==0 && ED==2 &&  FULL) (negedge SRC  *> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n    \n        if (EN && DD==1 && SD==1 && ED==0 && !FULL) (        SRC +=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==1 && SD==1 && ED==0 &&  FULL) (        SRC +*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==1 && SD==1 && ED==1 && !FULL) (posedge SRC +=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==1 && SD==1 && ED==1 &&  FULL) (posedge SRC +*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==1 && SD==1 && ED==2 && !FULL) (negedge SRC +=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==1 && SD==1 && ED==2 &&  FULL) (negedge SRC +*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n    \n        if (EN && DD==1 && SD==2 && ED==0 && !FULL) (        SRC -=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==1 && SD==2 && ED==0 &&  FULL) (        SRC -*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==1 && SD==2 && ED==1 && !FULL) (posedge SRC -=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==1 && SD==2 && ED==1 &&  FULL) (posedge SRC -*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==1 && SD==2 && ED==2 && !FULL) (negedge SRC -=> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==1 && SD==2 && ED==2 &&  FULL) (negedge SRC -*> (DST +: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n    \n        // DD=2\n    \n        if (EN && DD==2 && SD==0 && ED==0 && !FULL) (        SRC  => (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==2 && SD==0 && ED==0 &&  FULL) (        SRC  *> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==2 && SD==0 && ED==1 && !FULL) (posedge SRC  => (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==2 && SD==0 && ED==1 &&  FULL) (posedge SRC  *> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==2 && SD==0 && ED==2 && !FULL) (negedge SRC  => (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==2 && SD==0 && ED==2 &&  FULL) (negedge SRC  *> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n    \n        if (EN && DD==2 && SD==1 && ED==0 && !FULL) (        SRC +=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==2 && SD==1 && ED==0 &&  FULL) (        SRC +*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==2 && SD==1 && ED==1 && !FULL) (posedge SRC +=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==2 && SD==1 && ED==1 &&  FULL) (posedge SRC +*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==2 && SD==1 && ED==2 && !FULL) (negedge SRC +=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==2 && SD==1 && ED==2 &&  FULL) (negedge SRC +*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n    \n        if (EN && DD==2 && SD==2 && ED==0 && !FULL) (        SRC -=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==2 && SD==2 && ED==0 &&  FULL) (        SRC -*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==2 && SD==2 && ED==1 && !FULL) (posedge SRC -=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==2 && SD==2 && ED==1 &&  FULL) (posedge SRC -*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==2 && SD==2 && ED==2 && !FULL) (negedge SRC -=> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n        if (EN && DD==2 && SD==2 && ED==2 &&  FULL) (negedge SRC -*> (DST -: DAT)) = (T_RISE_MIN:T_RISE_TYP:T_RISE_MAX, T_FALL_MIN:T_FALL_TYP:T_FALL_MAX);\n    endspecify\n    `endif\n    \nendmodule",
      "inputs": ["\\DAT", "\\DST", "\\SRC", "\\EN"],
      "outputs": [],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$specrule": {
      "title": "",
      "ports": "(EN_SRC, EN_DST, SRC, DST)",
      "source": "simlib.v:1669",
      "desc": "",
      "code": "module \\$specrule (EN_SRC, EN_DST, SRC, DST);\n    \n    parameter TYPE = \"\";\n    parameter T_LIMIT = 0;\n    parameter T_LIMIT2 = 0;\n    \n    parameter SRC_WIDTH = 1;\n    parameter DST_WIDTH = 1;\n    \n    parameter SRC_PEN = 0;\n    parameter SRC_POL = 0;\n    \n    parameter DST_PEN = 0;\n    parameter DST_POL = 0;\n    \n    input EN_SRC, EN_DST;\n    input [SRC_WIDTH-1:0] SRC;\n    input [DST_WIDTH-1:0] DST;\n    \n    `ifdef SIMLIB_SPECIFY\n    specify\n        // TBD\n    endspecify\n    `endif\n    \nendmodule",
      "inputs": ["\\DST", "\\SRC", "\\EN_DST", "\\EN_SRC"],
      "outputs": [],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$sr": {
      "title": "",
      "ports": "(SET, CLR, Q)",
      "source": "simlib.v:1954",
      "desc": "",
      "code": "module \\$sr (SET, CLR, Q);\n    \n    parameter WIDTH = 0;\n    parameter SET_POLARITY = 1'b1;\n    parameter CLR_POLARITY = 1'b1;\n    \n    input [WIDTH-1:0] SET, CLR;\n    output reg [WIDTH-1:0] Q;\n    \n    wire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;\n    wire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;\n    \n    genvar i;\n    generate\n        for (i = 0; i < WIDTH; i = i+1) begin:bitslices\n            always @*\n                if (pos_clr[i])\n                    Q[i] <= 0;\n                else if (pos_set[i])\n                    Q[i] <= 1;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\CLR", "\\SET"],
      "outputs": ["\\Q"],
      "properties": {"is_combinatorial": false, "is_evaluable": false, "is_synthesizable": false}
    },
    "$sshl": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:436",
      "desc": "",
      "code": "module \\$sshl (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) <<< B;\n        end else begin:BLOCK2\n            assign Y = A <<< B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$sshr": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:461",
      "desc": "",
      "code": "module \\$sshr (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) >>> B;\n        end else begin:BLOCK2\n            assign Y = A >>> B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$sub": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:884",
      "desc": "",
      "code": "module \\$sub (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) - $signed(B);\n        end else begin:BLOCK2\n            assign Y = A - B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$tribuf": {
      "title": "",
      "ports": "(A, EN, Y)",
      "source": "simlib.v:1506",
      "desc": "",
      "code": "module \\$tribuf (A, EN, Y);\n    \n    parameter WIDTH = 0;\n    \n    input [WIDTH-1:0] A;\n    input EN;\n    output [WIDTH-1:0] Y;\n    \n    assign Y = EN ? A : 'bz;\n    \nendmodule",
      "inputs": ["\\EN", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$xnor": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:219",
      "desc": "A bit-wise XNOR. This corresponds to the Verilog '~^' operator.",
      "code": "module \\$xnor (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) ~^ $signed(B);\n        end else begin:BLOCK2\n            assign Y = A ~^ B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    },
    "$xor": {
      "title": "",
      "ports": "(A, B, Y)",
      "source": "simlib.v:188",
      "desc": "A bit-wise XOR. This corresponds to the Verilog '^' operator.",
      "code": "module \\$xor (A, B, Y);\n    \n    parameter A_SIGNED = 0;\n    parameter B_SIGNED = 0;\n    parameter A_WIDTH = 0;\n    parameter B_WIDTH = 0;\n    parameter Y_WIDTH = 0;\n    \n    input [A_WIDTH-1:0] A;\n    input [B_WIDTH-1:0] B;\n    output [Y_WIDTH-1:0] Y;\n    \n    generate\n        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n            assign Y = $signed(A) ^ $signed(B);\n        end else begin:BLOCK2\n            assign Y = A ^ B;\n        end\n    endgenerate\n    \nendmodule",
      "inputs": ["\\B", "\\A"],
      "outputs": ["\\Y"],
      "properties": {"is_combinatorial": false, "is_evaluable": true, "is_synthesizable": false}
    }
  }
}
